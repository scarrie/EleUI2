<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<HostPackage>
		<Host autoClearCommandLineAfterSend="yes" printCommand="yes" USE_IRE_DRIVER_BUGFIX="yes" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mEchoLuaErrors="yes" runAllKeyMatches="no" AmbigousWidthGlyphsToBeWide="auto" mRawStreamDump="yes" mIsLoggingTimestamps="no" logDirectory="" logFileName="" logFileNameFormat="yyyy-MM-dd#HH-mm-ss" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="no" mEnableGMCP="yes" mEnableMSSP="yes" mEnableMSP="yes" mEnableMSDP="no" mMapStrongHighlight="no" mLogStatus="yes" mEnableSpellCheck="yes" mEnableUserDictionary="yes" mUseSharedDictionary="no" mShowInfo="no" mAcceptServerGUI="yes" mAcceptServerMedia="yes" mMapperUseAntiAlias="yes" mFORCE_MXP_NEGOTIATION_OFF="no" enableTextAnalyzer="yes" mRoomSize="1.1" mLineSize="13.0" mBubbleMode="no" mShowRoomIDs="no" mShowPanel="no" mHaveMapperScript="yes" mEditorAutoComplete="yes" mEditorTheme="Mudlet" mEditorThemeFile="Mudlet.tmTheme" mThemePreviewItemID="3" mThemePreviewType="trigger" mSearchEngineName="Google" mTimerSupressionInterval="00:00:10.000" mUseProxy="no" mProxyAddress="" mProxyPort="0" mProxyUsername="" mProxyPassword="" mAutoReconnect="yes" mSslTsl="no" mSslIgnoreExpired="yes" mSslIgnoreSelfSigned="yes" mSslIgnoreAll="yes" mDiscordAccessFlags="2495" mRequiredDiscordUserName="" mRequiredDiscordUserDiscriminator="" mSGRCodeHasColSpaceId="no" mServerMayRedefineColors="no" playerRoomPrimaryColor="#ff000000" playerRoomSecondaryColor="#ffffffff" playerRoomStyle="0" playerRoomOuterDiameter="120" playerRoomInnerDiameter="70" mDoubleClickIgnore="'&quot;" EditorSearchOptions="0">
			<name>Brax</name>
			<mInstalledPackages>
				<string>send-text-to-all-games</string>
				<string>deleteOldProfiles</string>
				<string>echo</string>
				<string>run-lua-code-v4</string>
				<string>AnimatedTimers</string>
				<string>Mapper</string>
				<string>AdjustableContainer</string>
			</mInstalledPackages>
			<url>elephant.org</url>
			<serverPackageName>nothing</serverPackageName>
			<serverPackageVersion>-1</serverPackageVersion>
			<port>4444</port>
			<borderTopHeight>187</borderTopHeight>
			<borderBottomHeight>55</borderBottomHeight>
			<borderLeftWidth>0</borderLeftWidth>
			<borderRightWidth>600</borderRightWidth>
			<wrapAt>80</wrapAt>
			<wrapIndentCount>0</wrapIndentCount>
			<mFgColor>#c0c0c0</mFgColor>
			<mBgColor>#000000</mBgColor>
			<mCommandFgColor>#717100</mCommandFgColor>
			<mCommandBgColor>#000000</mCommandBgColor>
			<mCommandLineFgColor>#808080</mCommandLineFgColor>
			<mCommandLineBgColor>#000000</mCommandLineBgColor>
			<mBlack>#000000</mBlack>
			<mLightBlack>#808080</mLightBlack>
			<mRed>#800000</mRed>
			<mLightRed>#ff0000</mLightRed>
			<mBlue>#0000e3</mBlue>
			<mLightBlue>#0000ff</mLightBlue>
			<mGreen>#008000</mGreen>
			<mLightGreen>#00ff00</mLightGreen>
			<mYellow>#808000</mYellow>
			<mLightYellow>#ffff00</mLightYellow>
			<mCyan>#008080</mCyan>
			<mLightCyan>#00ffff</mLightCyan>
			<mMagenta>#800080</mMagenta>
			<mLightMagenta>#ff00ff</mLightMagenta>
			<mWhite>#c0c0c0</mWhite>
			<mLightWhite>#ffffff</mLightWhite>
			<mDisplayFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,1,0</mDisplayFont>
			<mCommandLineFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,0,0</mCommandLineFont>
			<mCommandSeparator>;;</mCommandSeparator>
			<commandLineMinimumHeight>37</commandLineMinimumHeight>
			<mFgColor2>#c0c0c0</mFgColor2>
			<mBgColor2>#000000</mBgColor2>
			<mBlack2>#000000</mBlack2>
			<mLightBlack2>#808080</mLightBlack2>
			<mRed2>#800000</mRed2>
			<mLightRed2>#ff0000</mLightRed2>
			<mBlue2>#000080</mBlue2>
			<mLightBlue2>#0000ff</mLightBlue2>
			<mGreen2>#008000</mGreen2>
			<mLightGreen2>#00ff00</mLightGreen2>
			<mYellow2>#808000</mYellow2>
			<mLightYellow2>#ffff00</mLightYellow2>
			<mCyan2>#008080</mCyan2>
			<mLightCyan2>#00ffff</mLightCyan2>
			<mMagenta2>#800080</mMagenta2>
			<mLightMagenta2>#ff00ff</mLightMagenta2>
			<mWhite2>#c0c0c0</mWhite2>
			<mLightWhite2>#ffffff</mLightWhite2>
			<mSpellDic>en_US</mSpellDic>
			<mLineSize>13.0</mLineSize>
			<mRoomSize>1.1</mRoomSize>
			<stopwatches />
		</Host>
	</HostPackage>
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>UI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Honey Chat</name>
				<script>if not table.contains(chatBox.consoles,"Honey") then
  chatBox:addTab("Honey")
end
chatBox:cecho("Honey","&lt;cyan&gt;["..matches[2].."]&lt;reset&gt; "..matches[3].."\n")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[Honey\s?(.*)\] (.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>wimpy</name>
				<script>brax = brax or {}
brax.wimpy = matches[2]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Wimpydir now set to (.*).$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Wimpy</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>pspray</name>
				<script>brax = brax or {}
brax.wimpy = brax.wimpy or exitmap[reversemap[gmcp.Char.Moved]]
--display(matches)
local who = matches[2]
local what = matches[3]
local spelltarget = matches[4]
if string.lower(spelltarget) == "you" then
  if brax.wimpy then send(brax.wimpy) else send(exitmap[reversemap[gmcp.Char.Moved]]) end
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w*) begins to cast (.*) at (\w*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Cast-Flee</name>
				<script>brax = brax or {}
brax.wimpy = brax.wimpy or {}
local avoid = {"Confusion","Force Cage"}
if table.contains(avoid,matches[2]) then
  send(brax.wimpy)
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* begins to cast (.*) at you\!\!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Crypt Teleport</name>
				<script>brax = brax or {}
brax.wimpy = brax.wimpy or gmcp.Char.Moved
send(brax.wimpy)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Crypt Thing begins to cast Crypt Teleport\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Combat</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>smack</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You (.*) in the (.*) with your (.*)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You deal a deadly blow.....to outer space!</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You deal a deadly blow.....to outer space!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sidesteps</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) sidesteps your poorly planned attack\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Laughs</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) laughs at your inept attack\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Dodges</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) dodges your inept attack\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>miss</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w*) misses (\w*) attack on (\w*)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>New trigger</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w*) missed you\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Hit_In</name>
				<script>cinsertText("🗡️")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) hits you (.*) in the (.*)\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Blast</name>
				<script>insertText("✨")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w*) thrusts both hands towards (\w*), who staggers backwards in pain\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Blast</name>
				<script>insertText("✨")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The energy racing into you reaches a peak</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Casting</name>
				<script>insertText("✨")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You begin to cast </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>PartyJoin</name>
			<script>send(matches[2])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You have 60 seconds to type \'(.*)\'\.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>PartyAdd</name>
			<script>send("party add "..matches[2]) </script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>\] add (.*)</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>(-)*</name>
			<script>deleteLine()
decho("&lt;128,0,128&gt;\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^\(\-\)\*</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>&lt;TRUNCATED&gt;</name>
			<script>selectString("&lt;TRUNCATED&gt;",1)
replace("")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>&lt;TRUNCATED&gt;</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>roomDesc</name>
			<script>if getRoomUserData(getRoomIDbyHash(gmcp.Room.Id), "description") == "" then
  setRoomUserData(getRoomIDbyHash(gmcp.Room.Id), "description",line)
end
disableTrigger("roomDesc") </script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(.*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>CombatPrompt</name>
			<script>if brax.target.hp then
insertText(brax.target.name..":"..math.floor(brax.target.hp * 100).."% ")
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Hp: (\d*)    Mp: (\d*)      Sp: (\d*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>You have discovered a new part of the Western Realms!</name>
			<script>setRoomUserData(eleMap.currentRoom,"ExploredRoom","true")
postHTTP("roomid="..gmcp.Room.Id, "https://dev.khviii.info/~dkearns/ele/")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You have discovered a new part of the Western Realms\!</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Hole</name>
			<script>send("out")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Shambler begins to shimmer and then fades into nothingness</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Sanc</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand>sanc</mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>You feel the effects of sanctuary wear off.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AutoMount</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand>mount horse</mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Your Ethereal Palfrey gallops into the room.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>AnimatedTimers</name>
			<script></script>
			<command></command>
			<packageName>AnimatedTimers</packageName>
			<time></time>
			<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>Animate</name>
				<script>demonnic.anitimer:animate()</script>
				<command></command>
				<packageName></packageName>
				<time>00:00:00.005</time>
			</Timer>
		</TimerGroup>
		<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>UI</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<time>00:00:00.000</time>
			<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
				<name>xph</name>
				<script>getXPH()</script>
				<command></command>
				<packageName></packageName>
				<time>00:01:00.000</time>
			</Timer>
		</TimerGroup>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>send-text-to-all-games</name>
			<script></script>
			<command></command>
			<packageName>send-text-to-all-games</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Send text to all games with :</name>
				<script>-- prefix with : to send text or run an alias in all open profiles that have this script installed
-- for example - :hi or :follow bob
local matchedText = matches[2]
expandAlias(matchedText)
raiseGlobalEvent("sysSendAllProfiles", matchedText)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^:(.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>deleteOldProfiles</name>
			<script></script>
			<command></command>
			<packageName>deleteOldProfiles</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>delete old profiles</name>
				<script>deleteOldProfiles(matches[3], matches[2]=="maps")

--Syntax examples: "delete old profiles"  -&gt; deletes profiles older than 31 days
--					"delete old maps 10"	-&gt; deletes maps older than 10 days</script>
				<command></command>
				<packageName></packageName>
				<regex>^delete old (profiles|maps)(?: (\d+))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>echo</name>
			<script></script>
			<command></command>
			<packageName>echo</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>`echo</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
feedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`echo (.+)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>run-lua-code-v4</name>
			<script></script>
			<command></command>
			<packageName>run-lua-code-v4</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>run lua code</name>
				<script>local f, e = loadstring("return "..matches[2])
if not f then
  f, e = assert(loadstring(matches[2]))
end

local r =
  function(...)
    if not table.is_empty({...}) then
      display(...)
    end
  end
r(f())</script>
				<command></command>
				<packageName></packageName>
				<regex>^lua (.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>UI Aliases</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>UI Menu</name>
				<script>local cmd = matches[2]
if cmd == "save" then
  saveWindows()
elseif cmd == "load" then
  loadWindows()
elseif cmd == "config" then
  toggleBox(configContainer)
elseif cmd == "installmap" then
  loadMap(getMudletHomeDir().."/EleUI2/EleUI2Map.dat")
  find_room()
elseif cmd == "startmap" then
  mapper_Installed()
elseif cmd == "theme" then
  ui_Theme(matches[3])
elseif cmd == "routes" then
  uiRoutes(matches[3])
elseif cmd == "stop" then
  print("STOPPING")
  brax.STOP = true
elseif cmd == "mapmode" then
  if brax.map.mode == "read" then
    brax.map.mode = "simple"
    cecho("&lt;cyan&gt;»»&lt;reset&gt;MapMode: Simple&lt;cyan&gt;««&lt;reset&gt;\n")
  elseif brax.map.mode == "simple" then
    brax.map.mode = "full"
    cecho("&lt;cyan&gt;»»&lt;reset&gt;MapMode: Full&lt;cyan&gt;««&lt;reset&gt;\n")
  elseif brax.map.mode == "full" then
    brax.map.mode = "read"
    cecho("&lt;cyan&gt;»»&lt;reset&gt;MapMode: Follow&lt;cyan&gt;««&lt;reset&gt;\n")
  end
elseif cmd == "update" then
  GitUpdater()
elseif cmd == "note" then
  local roomNote = getRoomUserData(eleMap.currentRoom,"RoomNote") or ""
  if matches[3] ~= "" then
    decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
    decho(matches[3].."\n") 
    decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
    setRoomUserData(eleMap.currentRoom,"RoomNote",matches[3])    
  elseif roomNote ~= ""  then 
    decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
    decho(roomNote.."\n") 
    decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
  end
elseif cmd == "clearnote" then
  clearRoomUserData(eleMap.currentRoom,"RoomNote")
elseif cmd == "roomcmd" then
  setRoomUserData(eleMap.currentRoom,"roomCMD",matches[3])    
elseif cmd == "exitcmd" then
  local e_dir = matches[3]:match("^(%w*)")
  local e_cmd = matches[3]:match("^%w* (.*)")
  if e_cmd == "clear" then
    setDoor(eleMap.currentRoom,e_dir,0)
    clearRoomUserDataItem(eleMap.currentRoom,"Exit_"..e_dir)
  else
    setDoor(eleMap.currentRoom,e_dir,1)
    setRoomUserData(eleMap.currentRoom,"Exit_"..e_dir,e_cmd)
  end
else
  decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
  decho("ui help       - this page!\n")
  decho("ui save       - Saves current window layout!\n")
  decho("ui load       - Loads current window layout!\n")
  decho("ui config     - Displays the UI Config window!\n")
  decho("ui theme &lt;x&gt;  - Changes border colour to x (red|green|purple|#660000|etc)\n")
  decho("ui routes     - Show speedwalk menu\n")
  decho("ui routes &lt;x&gt; - Speedwalk to destination\n")
  decho("ui stop       - Kills speedwalking instantly\n")
  decho("ui mapmode    - Toggle Mapmode (Follow/Simple/Full) Current:"..brax.map.mode.."\n")
  decho("ui startmap   - Will Set mapmode to full, and create first room based on current location\n")
  decho("ui exitcmd    - Takes two commands, dir and command ie 'ui exitcmd ne open gate'\n")
  decho("              -  Used in speedwalking routes to auto open doors/gates etc\n")
  decho("ui note &lt;x&gt;   - Display any custom notes for current room\n")
  decho("ui clearnote  - Check for updates\n")
  decho("ui update     - Check for updates\n")
  decho("                UI "..brax.version.."\n")
  decho("&lt;128,0,128&gt;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^ui (\w*) ?(.*)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>AnimatedTimers</name>
			<script></script>
			<command></command>
			<packageName>AnimatedTimers</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>anitimer demo</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex>^anitimer demo$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>map getdesc</name>
			<script>enableTrigger("roomDesc")
send("look")</script>
			<command></command>
			<packageName></packageName>
			<regex>^map getdesc$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>tt</name>
			<script>local _,t = next(gmcp.Char.Attackers.Attack)
send("target "..t)

</script>
			<command></command>
			<packageName></packageName>
			<regex>^t$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>phole</name>
			<script>local item = matches[2]
send("drop hole;;enter hole;;drop "..item..";;out;;get hole")</script>
			<command></command>
			<packageName></packageName>
			<regex>^phole (\w*)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>send-text-to-all-games</name>
			<packageName>send-text-to-all-games</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>sysSendAllProfiles</name>
				<packageName></packageName>
				<script>function sysSendAllProfiles(_, text)
  expandAlias(text)
end</script>
				<eventHandlerList>
					<string>sysSendAllProfiles</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>deleteOldProfiles</name>
			<packageName>deleteOldProfiles</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>deleteOldProfiles script</name>
				<packageName></packageName>
				<script>function deleteOldProfiles(keepdays_arg, delete_maps)

--[[
	Deletes old profiles/maps in the "current"/"map" folders of the Mudlet home directory.
	The following files are NOT deleted:
	- Files newer than the amount of days specified as an argument to deleteOldProfiles(), or 31 days if not specified.	
	- One file for every month before that. Specifically: The first available file of every month prior to this.
	Setting the second argument to true will delete maps instead of profiles. (e.g. deleteOldProfiles(10, true))
--]]

	local keepdays = tonumber(keepdays_arg) or 31
	local profile_table = {}
	local used_last_mod_months = {}
	local slash = (string.char(getMudletHomeDir():byte()) == "/") and "/" or "\\"
	local dirpath = getMudletHomeDir()..slash..(delete_maps and "map" or "current")
	local delnum = 0

	-- Traverse the profiles folder and create a table of files:
	for filename in lfs.dir(dirpath) do
		if filename~="." and filename~=".." then
			profile_table[#profile_table+1] = {name = filename, last_mod = lfs.attributes(dirpath..slash..filename, "modification")}
		end
	end

	-- Sort the table according to last modification date from old to new:
	table.sort(profile_table, function (a,b) return a.last_mod &lt; b.last_mod end)

	echo(string.format("\nDeleting old %s. Files newer than %d days and one profile for every month before that will be kept.", delete_maps and "maps" or "profiles", keepdays))
	for i,v in ipairs(profile_table) do
		local days = math.floor(os.difftime(os.time(), v.last_mod)/86400)
		local last_mod_month = os.date("%Y/%m", v.last_mod)
		if days &gt; keepdays then
			-- For profiles older than X days, check if we already kept a table for this month:
			if not table.contains(used_last_mod_months, last_mod_month) then
				-- If not, do nothing and mark this month as "kept".
				used_last_mod_months[#used_last_mod_months+1] = last_mod_month
			else
				-- Otherwise remove the file:
				local success, errorstring = os.remove(dirpath..slash..v.name)
				if success then
					delnum = delnum + 1
				else
					cecho("\n&lt;red&gt;ERROR: "..errorstring)
				end
			end
		end
	end
	echo(string.format("\nDeletion complete. %d/%d files were removed successfully.", delnum, #profile_table))
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Testing</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Inventory</name>
				<packageName></packageName>
				<script>function charItems()
--display(gmcp.Char.Items)
  local id,item = next(gmcp.Char.Items)
--display(item)
  if item == 0 then
    brax.items[id] = nil
  else
--  display(gmcp.Char.Items)
    local tempItem = {}
    tempItem[id] = item
--    display(tempItem)
--    brax.items = table.update(brax.items,tempItem)
  end
end

function testItems()
  for id,item in pairs(brax.items) do
  if item.name == nil then item.name = "" end
  if item.subtype == nil then item.subtype = "" end
    print(item.subtype..":"..item.name)
  end
end

registerAnonymousEventHandler("gmcp.Char.Items","charItems")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>Target</name>
				<packageName></packageName>
				<script>function targetHP()
if true then return end
  gmcp.Char.Target = gmcp.Char.Target or {}
  gmcp.Char.Target.Vitals = gmcp.Char.Target.Vitals or {}
  gmcp.Char.Target.Vitals.hp = gmcp.Char.Target.Vitals.hp or nil
  
  gmcp.Char.Attackers = gmcp.Char.Attackers or {}
  gmcp.Char.Attackers.Attack = gmcp.Char.Attackers.Attack or {}
  gmcp.Char.Attackers.Hunt = gmcp.Char.Attackers.Hunt or {}

  local info = ""
  targetContainer =
    targetContainer or
    Adjustable.Container:new({name = "targetContainer", titleText = "Target Info"})
  targetBox =
    targetBox or Geyser.Label:new(
      {name = "Target", color = "black", x = 0, y = 0, width = "100%", height = "100%"},
      targetContainer
    )
  targetBar = targetBar or Geyser.Gauge:new({name="targetBar",x="0%", y="5px",width="100%", height="15px"},targetContainer)
  targetBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
  if next(gmcp.Char.Attackers.Attack) ~= nil then
    info = info.."&lt;b&gt;*Attackers&lt;/b&gt;&lt;br&gt;"
    for i, who in pairs(gmcp.Char.Attackers.Attack) do
      info = info .. who .. "&lt;br&gt;"
    end
  end
  if next(gmcp.Char.Attackers.Hunt) ~= nil then
    info = info.."&lt;b&gt;Hunters&lt;/b&gt;&lt;br&gt;"
    for i, who in pairs(gmcp.Char.Attackers.Hunt) do
      info = info .. who .. "&lt;br&gt;"
    end
  end
  if gmcp.Char.Target.Vitals.hp then
    targetBar:setValue(gmcp.Char.Target.Vitals.hp,1,gmcp.Char.Target.name)
    brax.target.hp = string.format("%.1f",gmcp.Char.Target.Vitals.hp*100)
  else
    brax.target.hp = ""
  end
  if gmcp.Char.Target.target ~= gmcp.Char.Status.name then
  targetBar:show()
    --display(gmcp.Char.Target)
  else
    targetBar:hide()  
  end
  if gmcp.Char.Target.name then
    brax.target.name = gmcp.Char.Target.name
  else
    targetBar:hide()
    brax.target.name = ""
  end

  local ToTCast = ""
  if gmcp.Char.Target.Cast ~= nil then
  gmcp.Char.Target.Cast = gmcp.Char.Target.Cast or {}
  gmcp.Char.Target.Cast.spell = gmcp.Char.Target.Cast.spell or ""
  gmcp.Char.Target.Cast.target = gmcp.Char.Target.Cast.target or ""
      
--    display(gmcp.Char.Target.Cast)
  if gmcp.Char.Target.Cast.spell ~= "" then
if gmcp.Char.Target.Cast.cast_time &gt; 0 then
demonnic.anitimer:new(
        "T"..gmcp.Char.Target.Cast.spell,
        {x = 0, y = 17, height = 15, width = "100%"},
        gmcp.Char.Target.Cast.cast_time,
        {container = targetContainer, showTime = true, timerCaption = gmcp.Char.Target.Cast.spell, cssFront = frontCSS}
      )
    end
    ToTCast = gmcp.Char.Target.Cast.spell.." at "..gmcp.Char.Target.Cast.target.."&lt;br&gt;"
  end
  end

  local targetInfo = ""
  if gmcp.Char.Target.name ~= nil then 
    targetInfo = "&lt;red&gt;"..brax.target.name.."&lt;white&gt; :"..brax.target.hp.."%&lt;br&gt; "..ToTCast
  else 
    targetInfo = ""
  end
  --if gmcp.Char.Target then display(gmcp.Char.Target) end
  targetBox:echo("&lt;br&gt;&lt;br&gt;&lt;br&gt;"..info)
end

function castT()
--display(gmcp.Char.Target.Cast)
end

--registerAnonymousEventHandler("gmcp.Char.Target.Vitals", "targetHP")
--registerAnonymousEventHandler("gmcp.Char.Target", "targetHP")
--registerAnonymousEventHandler("gmcp.Char.Attackers", "targetHP")
--registerAnonymousEventHandler("gmcp.Char.Target.Cast", "targetHP")

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Skills</name>
				<packageName></packageName>
				<script>function skillsChanged()
--  display(gmcp.Char.Skills['conjuring'])
end
registerAnonymousEventHandler("gmcp.Char.Skills","skillsChanged")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>hotbar</name>
				<packageName></packageName>
				<script>function doHotbar()
  hotbarContainer = hotbarContainer or Adjustable.Container:new({x=30,y=30,name="hotbarContainer",titleText="hotbar",height="5c",width="100c"})
  brax.hotbar = brax.hotbar or {}
  brax.HBox = brax.HBox or Geyser.HBox:new({
  name="HBox",
  x=0, y=0,
  width="100%", height="100%",
  },hotbarContainer)
  local loadTable = {}
  if io.exists(getMudletHomeDir().."/EleUI2/hotbar.lua") then
      table.load(getMudletHomeDir().."/EleUI2/hotbar.lua", loadTable)
  end
  local saveTable = {}
  for i=1,10 do 
    brax.hotbar[i] = brax.hotbar[i] or {}
    brax.hotbar[i].box = brax.hotbar[i].box or Geyser.Label:new({name = "hotbar"..i, color = "black"},brax.HBox)
    brax.hotbar[i].box:setStyleSheet([[QLabel{background-color: black;border-width: 1px;border-style: solid;border-color: green;border-radius: 3px;}QLabel::hover {background-color:grey;}]])
    brax.hotbar[i].box:setAlignment("center")
    brax.hotbar[i].box:setClickCallback("hotbarClick",i)
    brax.hotbar[i].cmd = brax.hotbar[i].cmd or loadTable[i].cmd
    brax.hotbar[i].buff = brax.hotbar[i].buff or loadTable[i].buff
    saveTable[i] = {}
    saveTable[i].cmd = brax.hotbar[i].cmd
    saveTable[i].buff = brax.hotbar[i].buff
    if brax.hotbar[i].cmd then
      brax.hotbar[i].box:echo(brax.hotbar[i].cmd)
    end
    end
  if not(io.exists(getMudletHomeDir().."/EleUI2/")) then lfs.mkdir(getMudletHomeDir().."/EleUI2/") end
--  table.save(getMudletHomeDir().."/EleUI2/hotbar.lua", saveTable)
    
end

function hotbarClick(button)
  send(brax.hotbar[button].cmd)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>newWeights</name>
				<packageName></packageName>
				<script>function Geyser.nameAll(type)
  for _, v in pairs(Geyser.windowList) do
    if v.type == type or not type then
      print(v.name)
    end
  end
end


function getExploredRooms()
  local rooms = getRooms()
  for i, v in ipairs(rooms) do
    if getAllRoomUserData(i)['ExploredRoom'] then
      cechoLink(i.." - "..getRoomName(i).."\n",[[centerview(]]..i..[[)]],"",true)
    end
  end
end

function delSquareExits()
  local rooms = getRooms()
  for i, v in ipairs(rooms) do
    if getSpecialExitsSwap(i)['square'] then
    print(i)
    removeSpecialExit(i,'square')
    end
  end
end


function newWeights()
-- Paths = 1
-- Sea = Block

  local rooms = getRooms()
  for i, v in ipairs(rooms) do
    if getRoomEnv(i) == 267 then -- Yellow Path
--      setRoomWeight(i, 1)
    elseif getRoomEnv(i) == 260 then -- sea Blue (disable speedwalk)
--      lockRoom(i,true)
    elseif getRoomEnv(i) == 296 then -- sea Blue (disable speedwalk)
      lockRoom(i,false)
      setRoomWeight(i,10)
    else
      setRoomWeight(i,10)
    end
    if getAllRoomUserData(i)['ExploredRoom'] then
--      print(i.." - "..getRoomName(i))
      cechoLink(i.." - "..getRoomName(i).."\n",[[centerview(]]..i..[[)]],"",true)
    end
  end
end -- getpa getRoomIDbyHash

--R {    1} {0} {} {kera} { } {Inside a warm, friendly inn called the Elephant's Ears^[[0;37;40m} {} {aerdy.8.8} {} {aerdy.177.145107} {1.000}
--E {    2} {n} {n} {1} {0} {}
--E {   18} {ne} {ne} {3} {0} {}
--E {    3} {e} {e} {2} {0} {}
--E {   42} {se} {se} {6} {0} {}
--E {   18} {s} {s} {4} {0} {}
--E {   17} {sw} {sw} {12} {0} {}
--E {   35} {w} {w} {8} {0} {}
--E {   45} {nw} {nw} {9} {0} {}
--E {  420} {in} {in} {0} {0} {}
--E {  305} {out} {out} {0} {0} {}

function exportToTinTin()
  local rooms = getRooms()
  file = io.open (getMudletHomeDir()..[[/tt.map]] ,"w")
  io.output(file)
  local roomName = ""
  local roomHash = ""
  local dirNum = 0
  local roomExits = {}
  for i, v in ipairs(rooms) do
    roomName = getRoomName(i) or ""
    roomHash = getRoomHashByID(i) or ""
    roomExits = getRoomExits(i)
    io.write("R {"..i.."} {0} {} {"..roomName.."} {"..rgbToHex(getCustomEnvColorTable()[getRoomEnv(i)]).."} {} {} {"..roomHash.."} {} {} {1.000}\n")
      for dir, toRoom in pairs(roomExits) do
        if dir == "north" then dirNum = 1 end
        if dir == "northeast" then dirNum = 3 end
        if dir == "east" then dirNum = 2 end
        if dir == "southeast" then dirNum = 6 end
        if dir == "south" then dirNum = 4 end
        if dir == "southwest" then dirNum = 12 end
        if dir == "west" then dirNum = 8 end
        if dir == "northwest" then dirNum = 9 end
        io.write("E {"..toRoom.."} {"..dir.."} {"..dir.."} {"..dirNum.."} {0} {}\n")
      end
    io.write("\n")
  end
  io.close(file)
end 

function rgbToHex(rgb)
	local hexadecimal = ''
  if rgb == nil then return ' ' end
	for key, value in pairs(rgb) do
    local index = math.ceil(value/42.5)
    if index == 0 then index = 1 end
    hexadecimal = hexadecimal .. string.sub('abcdef', index, index)
	end

	return '&lt;'..hexadecimal..'&gt;#'
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>SwitchContainers</name>
				<packageName></packageName>
				<script>function switchContainer(event,details)
  display(event)
  display(details)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Skills Matrix</name>
				<packageName></packageName>
				<script>function skillsMatrix()
  brax = brax or {}
  brax.skills = brax.skills or {}
  brax.skills.warmage = brax.skills.warmage or {}
  brax.skills.warmage.scry = {}
  brax.skills.warmage.scry.cmd = "scry"
  brax.skills.warmage.scry.icon = getMudletHomeDir().."/EleUI2/imgs/pspray.png"
  brax.skills.warmage.blast = {}
  brax.skills.warmage.blast.cmd = "scry"
  brax.skills.warmage.blast.icon = getMudletHomeDir().."/EleUI2/imgs/blast.png"
  
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>xph</name>
				<packageName></packageName>
				<script>function getXPH()
  brax.XPH = brax.XPH or brax.xp
  local rate = (brax.xp - brax.XPH) * 60
  --print("XP Rate: "..comma_value(rate).." xp per Hours")
  brax.XPH = brax.xp
  brax.XPRate = rate
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>New script</name>
				<packageName></packageName>
				<script>function pins()
  local rooms =
    {
      "aerdy.115.671984","aerdy.122.283505","aerdy.122.306062","aerdy.130.642230","aerdy.130.893694",
      "aerdy.132.703436","aerdy.135.130901","aerdy.137.74180","aerdy.151.110827","aerdy.151.733333",
      "aerdy.151.789710","aerdy.177.443104","aerdy.177.579356","aerdy.177.795765","aerdy.178.493821",
      "aerdy.179.30511","aerdy.193.220250","aerdy.193.846494","aerdy.195.120709","aerdy.195.311181",
      "aerdy.195.385866","aerdy.196.688310","aerdy.197.493821","aerdy.198.986618","aerdy.199.639701",
      "aerdy.199.790196","aerdy.199.854443","aerdy.201.962797","aerdy.25.28344","aerdy.25.437038",
      "aerdy.34.345747","aerdy.34.715646","drakenwood.233.25063","drakenwood.239.562199",
      "drakenwood.239.724500","drakenwood.241.61780","drakenwood.69.113241","drakenwood.98.137928",
      "rosfarren.215.280201","rosfarren.215.754577","rosfarren.219.722571","rosfarren.219.853058",
      "rosfarren.220.486010","rosfarren.228.746949","rosfarren.228.88830","rosfarren.243.25179",
      "rosfarren.243.379049","rosfarren.244.243063","rosfarren.246.841053","rosfarren.247.213500",
      "valena.11.344111","valena.11.397200","valena.172.33406","valena.172.665057","valena.38.630561",
    }
  for id, hash in pairs(rooms) do
    setRoomChar(getRoomIDbyHash(hash), "📌")
  end
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>UI</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>onLoad</name>
				<packageName></packageName>
				<script>function get_Ready()
  print(":: Getting stuff ready....")
  gmcp = gmcp or {}
  gmcp.Char = gmcp.Char or {}
  gmcp.Char.Vitals = gmcp.Char.Vitals or {}
  gmcp.Char.Vitals.hp = gmcp.Char.Vitals.hp or 0
  gmcp.Char.Vitals.mp = gmcp.Char.Vitals.mp or 0
  gmcp.Char.Vitals.sp = gmcp.Char.Vitals.sp or 0
  gmcp.Char.Vitals.maxhp = gmcp.Char.Vitals.maxhp or 1
  gmcp.Char.Vitals.maxmp = gmcp.Char.Vitals.maxmp or 1
  gmcp.Char.Vitals.maxsp = gmcp.Char.Vitals.maxsp or 1
  gmcp.Char.Status = gmcp.Char.Status or {}
  gmcp.Char.Status.class = gmcp.Char.Status.class or {}
  gmcp.Char.Attackers = gmcp.Char.Attackers or {}
  gmcp.Char.Attackers.Hunt = gmcp.Char.Attackers.Hunt or {}
  gmcp.Char.Attackers.Attack = gmcp.Char.Attackers.Attack or {}
  
  brax = brax or {}
  brax.name = brax.name or gmcp.Char.Status.fullname
  brax.level = brax.level or gmcp.Char.Status.level
  brax.map = brax.map or {}
  brax.map.mode = brax.map.mode or "read"
  brax.version = "Version: 1.56"
  brax.speedwalkDelay = 0.3
  brax.xp = brax.xp or 0
  brax.class = brax.class or {}
  brax.class.prime = brax.class.prime or ""
  brax.class.second = brax.class.second or ""
  brax.party = brax.party or {}
  brax.party.Members = brax.party.Members or {}
  brax.party.Vitals = brax.party.Vitals or {}
  brax.items = brax.items or {}
  brax.target = brax.target or {}  
  brax.hotbar = brax.hotbar or {}
  brax.bell = true
  setDiscordApplicationID("689229426529140740")
  setDiscordLargeIcon("server-icon")
  setDiscordLargeIconText("Elephant MUD")
  setDiscordElapsedStartTime(os.time(os.date("*t")))
--  setDiscordDetail(brax.name.." ("..brax.level..")")

  local btnStyle = [[QLabel{ border-radius: 7px; background-color: rgba(140,140,140,100%);}QLabel::hover{ background-color: rgba(160,160,160,50%);}]]
  local adjStyle = [[border: 6px solid transparent;border-image: url(]]..getMudletHomeDir()..[[/EleUI2/imgs/oga.png) round;]]
-- adjLabelstyle=adjStyle, buttonstyle=btnStyle,

statBoxContainer = statBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=10,y=10,name="statBoxContainer",titleText="Vitals"})
  statsBox = Geyser.Label:new({name = "Stats", color = "black", x = 0, y = 0, width = "100%", height = "100%"},statBoxContainer)
  statsDetails = Geyser.Label:new({name = "Details", color = "black", x = 0, y = 125, width = "100%", height = "40px"},statsBox)  
  statsBox:setStyleSheet([[background:rgba(0,0,0,0)]])
  statsDetails:setStyleSheet([[background:rgba(0,0,0,0)]])
  hpbar = Geyser.Gauge:new({name="hpbar",x="0%", y="5px",width="100%", height="39px"},statsBox)
  statsDetails:setClickCallback("toggleXP")
  hpbar:setStyleSheet([[qproperty-alignment: 'AlignBottom';]])
  hpbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f04141, stop: 0.1 #ef2929, stop: 0.49 #cc0000, stop: 0.5 #a40000, stop: 1 #cc0000);
      border-top: 1px black solid;
      border-left: 1px black solid;
      border-bottom: 1px black solid;
      border-radius: 7;
      padding: 3px;]])
  hpbar.back:setStyleSheet([[background-color: black;
      border-width: 1px;
      border-color: #f04141;
      border-style: solid;
      border-radius: 7;
      padding: 3px;]])
  mpbar = Geyser.Gauge:new({name="mpbar",x="0%", y="45px",width="100%", height="35px"},statsBox)
  mpbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #9841f0, stop: 0.1 #8c29f0, stop: 0.49 #6600cc, stop: 0.5 #5200a3, stop: 1 #6600cc);
      border-top: 1px black solid;
      border-left: 1px black solid;
      border-bottom: 1px black solid;
      border-radius: 7;
      padding: 3px;]])
  mpbar.back:setStyleSheet([[background-color: black;
      border-width: 1px;
      border-color: #9841f0;
      border-style: solid;
      border-radius: 7;
      padding: 3px;]])
  spbar = Geyser.Gauge:new({name="spbar",x="0%", y="85px",width="100%", height="35px"},statsBox)
  spbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #98f041, stop: 0.1 #8cf029, stop: 0.49 #66cc00, stop: 0.5 #52a300, stop: 1 #66cc00);
      border-top: 1px black solid;
      border-left: 1px black solid;
      border-bottom: 1px black solid;
      border-radius: 7;
      padding: 3px;]])
  spbar.back:setStyleSheet([[background-color: black;
      border-width: 1px;
      border-color: #98f041;
      border-style: solid;
      border-radius: 7;
      padding: 3px;]])
statBoxContainer:hide()

buffBoxContainer = buffBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=20,y=20,name="buffBoxContainer",titleText="Buffs / Debuffs Status"})
  buffBox = Geyser.Label:new({name = "Buffs", color = "black", x = 0, y = 0, width = "100%", height = "100%"},buffBoxContainer)
  buffBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
  buffBox:setStyleSheet([[background:rgba(0,0,0,0)]])
buffBoxContainer:hide()

bodyBoxContainer = bodyBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,name="bodyBoxContainer",titleText="Body Damage"})
  bodyBox = Geyser.Label:new({name = "Body", color = "black", x = 0, y = 0, width = "100%", height = "100%"},bodyBoxContainer)
  bodyBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
  bodyBox:setStyleSheet([[background:rgba(0,0,0,0)]])
bodyBoxContainer:hide()

cooldownBoxContainer = cooldownBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=30,y=30,name="cooldownBoxContainer",titleText="Outstanding Cooldowns"})
  cooldownBox = Geyser.Label:new({name = "Cooldowns", color = "black", x = 0, y = 0, width = "100%", height = "100%"},cooldownBoxContainer)
  cooldownBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
  cooldownBox:raise()
  cooldownBox:setStyleSheet([[background:rgba(0,0,0,0)]])
cooldownBoxContainer:hide()

mapBoxContainer = mapBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=40,y=40,name="mapBoxContainer",titleText="You Are Here!"})
mapBoxContainer:hide()

chatBoxContainer = chatBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=50,y=50,name="chatBoxContainer",titleText="Chat"})
  local stylesheet = [[background-color: rgb(0,0,0,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  local istylesheet = [[background-color: rgb(60,60,60,255); border-width: 1px; border-style: solid; border-color: gold; border-radius: 10px;]]
  local _stylesheet = [[
        QLabel{
				background-color: #4d0000;
				border-style: outset;
        border-width: 2px;
        border-color: "#996600";
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';
				}				
				QLabel::hover{
				background-color: #b30000;
				border-style: outset;
        border-width: 2px;
        border-color: "#996600";
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';
				}				
				]]
  local _istylesheet = [[
        QLabel{
				background-color: #b30000;
				border-style: outset;
        border-width: 2px;
        border-color: "#996600";
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';
				}				
				QLabel::hover{
				background-color: #b30000;
				border-style: outset;
        border-width: 2px;
        border-color: "#996600";
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';
				]]

  chatBox = EMCO:new({ x = "0", y = "0", width = "100%", height = "100%", gap = 2, consoles = {"Tell"},activeTabCSS = _stylesheet, inactiveTabCSS = _istylesheet},chatBoxContainer)
  chatBox.tabBoxLabel:setStyleSheet([[background-color: rgba(0,0,0,0);]])
  chatBox:enableScrollbars()
  chatBox:enableBlink()
chatBoxContainer:hide()
  
castbarBoxContainer = castbarBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=60,y=60,name="castbarBoxContainer",titleText="Casting"})
--  castbarBox = Geyser.Label:new({name = "Casting", color = "black", x = 0, y = 0, width = "100%", height = "100%"},cooldownBoxContainer)
--  castbarBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
--  castbarBoxContainer:resize(300,50)
castbarBoxContainer:hide()

partyContainer = partyContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=10,y=10,name="partyContainer",titleText="Party"})
  partyBox = Geyser.Label:new({name = "Party", color = "black", x = 0, y = 0, width = "100%", height = "100%"},partyContainer)
  partyBox:setStyleSheet([[qproperty-alignment: 'AlignTop';]])
  partyBox:setStyleSheet([[background:rgba(0,0,0,0)]])
  do_Config()
-- 💾

-- Black's
targetBoxContainer = targetBoxContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,x=100,y=100,name = "targetBoxContainer", titleText = "Target Info"})
  targetBar = targetBar or Geyser.Gauge:new({name="targetBar",x="0%", y="5px",width="100%", height="15px"},targetBoxContainer)
  targetBox = targetBox or Geyser.Label:new( {name = "targetBox", color = "black", x = 0, y = "25px", width = "100%", height = "70%"}, targetBoxContainer)
  targetBox:setStyleSheet([[qproperty-alignment: 'AlignTop';background-color:rgba(70,70,70,0%)]])
  targetBoxContainer:hide()
targetBar:hide()

Adjustable.Container.loadAll()

uninstallPackage("generic_mapper")
mudlet = mudlet or {}; mudlet.mapper_script = true
eleMap = eleMap or {}
eleMap.mode = 0 				-- 1 = edit, 0=follow

eleMap = Geyser.Mapper:new({
  name = "eleMap",
  x = 0, y = 0,
  width = "100%",
  height = "100%",
},mapBoxContainer)

end

function do_Config()
  local configCSS = [[QLabel{padding-left:25px;background:rgba(0,0,0,0);}QLabel::hover {background-image : url("]]..getMudletHomeDir()..[[/EleUI2/imgs/FF7Cursor.png"); background-repeat:no-repeat;};]]
  local btnStyle = [[QLabel{ border-radius: 7px; background-color: rgba(140,140,140,100%);}QLabel::hover{ background-color: rgba(160,160,160,50%);}]]
  local adjStyle = [[border: 6px solid transparent;border-image: url(]]..getMudletHomeDir()..[[/EleUI2/imgs/oga.png) round;]]
  configContainer = configContainer or Adjustable.Container:new({adjLabelstyle=adjStyle, buttonstyle=btnStyle,name="configContainer",titleText="Config",width="200px", height="230px"})
  configStats = configStats or Geyser.Label:new({name = "configStats", color = "black", x = 0, y = 0, width = "100%", height = "20"},configContainer)
  configStats:setStyleSheet(configCSS)
  configStats:setClickCallback("toggleBox",statBoxContainer)
  local hiddenState = ""
  if (statBoxContainer.hidden == false) then hiddenState = "✔️" end
  configStats:echo("Stats Window "..hiddenState)

  configBuffs = configBuffs or Geyser.Label:new({name = "configBuffs", color = "black", x = 0, y = 20, width = "100%", height = "20"},configContainer)
  configBuffs:setStyleSheet(configCSS)
  configBuffs:setClickCallback("toggleBox",buffBoxContainer)
  local hiddenState = ""
  if (buffBoxContainer.hidden == false) then hiddenState = "✔️" end
  configBuffs:echo("Buffs/Debuffs Window "..hiddenState)

  configBody = configBody or Geyser.Label:new({name = "configBody", color = "black", x = 0, y = 40, width = "100%", height = "20"},configContainer)
  configBody:setStyleSheet(configCSS)
  configBody:setClickCallback("toggleBox",bodyBoxContainer)
  local hiddenState = ""
  if (bodyBoxContainer.hidden == false) then hiddenState = "✔️" end
  configBody:echo("Limb Damage Window "..hiddenState)

  configCooldowns = configCooldowns or Geyser.Label:new({name = "configCooldown", color = "black", x = 0, y = 60, width = "100%", height = "20"},configContainer)
  configCooldowns:setStyleSheet(configCSS)
  configCooldowns:setClickCallback("toggleBox",cooldownBoxContainer)
  local hiddenState = ""
  if (cooldownBoxContainer.hidden == false) then hiddenState = "✔️" end
  configCooldowns:echo("Cooldowns Window "..hiddenState)

  chatCooldowns = chatCooldowns or Geyser.Label:new({name = "chatCooldown", color = "black", x = 0, y = 80, width = "100%", height = "20"},configContainer)
  chatCooldowns:setStyleSheet(configCSS)
  chatCooldowns:setClickCallback("toggleBox",chatBoxContainer)
  local hiddenState = ""
  if (chatBoxContainer.hidden == false) then hiddenState = "✔️" end
  chatCooldowns:echo("Chat Window "..hiddenState)

  configMap = configMap or Geyser.Label:new({name = "configmap", color = "black", x = 0, y = 100, width = "100%", height = "20"},configContainer)
  configMap:setStyleSheet(configCSS)
  configMap:setClickCallback("toggleBox",mapBoxContainer)
  local hiddenState = ""
  if (mapBoxContainer.hidden == false) then hiddenState = "✔️" end
  configMap:echo("Map "..hiddenState)

  configcastbar = configcastbar or Geyser.Label:new({name = "configcastbar", color = "black", x = 0, y = 120, width = "100%", height = "20"},configContainer)
  configcastbar:setStyleSheet(configCSS)
  configcastbar:setClickCallback("toggleBox",castbarBoxContainer)
  local hiddenState = ""
  if (castbarBoxContainer.hidden == false) then hiddenState = "✔️" end
  configcastbar:echo("CastBar "..hiddenState)

  partyInfo = partyInfo or Geyser.Label:new({name = "partyInfo", color = "black", x = 0, y = 140, width = "100%", height = "20"},configContainer)
  partyInfo:setStyleSheet(configCSS)
  partyInfo:setClickCallback("toggleBox",partyContainer)
  local hiddenState = ""
  if (partyContainer.hidden == false) then hiddenState = "✔️" end
  partyInfo:echo("Party Info "..hiddenState)

  targetInfo = targetInfo or Geyser.Label:new({name = "targetInfo", color = "black", x = 0, y = 160, width = "100%", height = "20"},configContainer)
  targetInfo:setStyleSheet(configCSS)
  targetInfo:setClickCallback("toggleBox",targetBoxContainer)
  local hiddenState = ""
  if (targetInfo.hidden == false) then hiddenState = "✔️" end
  targetInfo:echo("Target Info "..hiddenState)


  configSave = configSave or Geyser.Label:new({name = "configSave", color = "black", x = 0, y = 180, width = "100%", height = "20"},configContainer)
  configSave:setStyleSheet(configCSS)
  configSave:setClickCallback("saveWindows")
  configSave:echo("Save Layout")
  
  configLoad = configLoad or Geyser.Label:new({name = "configLoad", color = "black", x = 0, y = 200, width = "100%", height = "20"},configContainer)
  configLoad:setStyleSheet(configCSS)
  configLoad:setClickCallback("loadWindows")
  configLoad:echo("Load Layout")
end

map = {}
function map.eventHandler()
end

function first_Install(_, pkg)
  if pkg == "EleUI2" then
    uninstallPackage("generic_mapper")
--    mapper_Installed()
    cecho("&lt;cyan&gt;»»&lt;reset&gt;Ele Drag and Drop UI Installed&lt;cyan&gt;««&lt;reset&gt;\n")
    cecho("&lt;cyan&gt;»»&lt;reset&gt;Commands: &lt;cyan&gt;««&lt;reset&gt;\n")
    cecho("&lt;cyan&gt;»»&lt;reset&gt;ui config - shows config window&lt;cyan&gt;««&lt;reset&gt;\n")
    cecho("&lt;cyan&gt;»»&lt;reset&gt;ui installmap - Installs pre-filled map&lt;cyan&gt;««&lt;reset&gt;\n")
    get_Ready()
  for  k,v in pairs(Geyser.windowList) do
    if v.type == "adjustablecontainer" then 
      v:hide()
    end
  end
  end
end

function getName()
  brax.name = gmcp.Char.Status.fullname
end
function getLevel()
  brax.level = gmcp.Char.Status.level
  if brax.name and brax.level then
    setDiscordDetail(brax.name.." ("..brax.level..")")
  end
end

registerAnonymousEventHandler("sysLoadEvent", "get_Ready")
registerAnonymousEventHandler("sysInstallPackage", "first_Install")
registerAnonymousEventHandler("gmcp.Char.Status.level", "getLevel")
registerAnonymousEventHandler("gmcp.Char.Status.fullname", "getName")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>vitals</name>
				<packageName></packageName>
				<script>function update_statsBox()
    local prime,second = unpack(gmcp.Char.Status.class)
    brax.class.prime = prime or ""
    brax.class.second = second or ""
    if (brax.class.second == "") then brax.class.second = "" else brax.class.second =  "/" .. brax.class.second end
    brax.xp = gmcp.Char.Vitals.exp
    if brax.xpType == true then brax.xp = brax.xp - brax.curXP end  
    statsDetails:echo(
    [[&lt;span style="style="font-family: 'Game Played';font-size:15px;"&gt;&lt;center&gt; ]] .. string.upper(brax.class.prime .. brax.class.second) ..[[&lt;/span&gt;
    &lt;br&gt;&lt;span style="font-size:15px"&gt;&lt;centerd&gt;XP ]] .. comma_value(brax.xp) ..[[&lt;/span&gt;]]
    )
    hpbar.text:echo([[&lt;span style="font-family: 'Game Played';font-size:25px;"&gt;&amp;nbsp;HP:]] .. gmcp.Char.Vitals.hp .. [[/&lt;span style="font-size:15px"&gt;]] .. gmcp.Char.Vitals.maxhp ..[[&lt;/span&gt;]])
    mpbar.text:echo([[&lt;span style="font-family: 'Game Played';font-size:25px;"&gt;&amp;nbsp;MP:]] .. gmcp.Char.Vitals.mp .. [[/&lt;span style="font-size:15px"&gt;]] .. gmcp.Char.Vitals.maxmp ..[[&lt;/span&gt;]])
    spbar.text:echo([[&lt;span style="font-family: 'Game Played';font-size:25px;"&gt;&amp;nbsp;SP:]] .. gmcp.Char.Vitals.sp .. [[/&lt;span style="font-size:15px"&gt;]] .. gmcp.Char.Vitals.maxsp ..[[&lt;/span&gt;]])
    hpbar:setValue(gmcp.Char.Vitals.hp,gmcp.Char.Vitals.maxhp)
    mpbar:setValue(gmcp.Char.Vitals.mp,gmcp.Char.Vitals.maxmp)
    spbar:setValue(gmcp.Char.Vitals.sp,gmcp.Char.Vitals.maxsp)
end

function comma_value(amount)
if amount then
  local formatted = amount
  while true do  
    formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    if (k==0) then
      break
    end
  end
  return formatted
  else
    return ""
  end
end
-- postHTTP(gmcp.Room.Id,"https://dev.khviii.info/~dkearns/ele/")
function toggleXP()
  brax.xp = gmcp.Char.Vitals.exp
  brax.curXP = brax.xp
--  brax.XPH = nil
  brax.xpType = not brax.xpType
  update_statsBox()
  getXPH()
end


registerAnonymousEventHandler("gmcp.Char.Vitals", "update_statsBox")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>roomItems</name>
				<packageName></packageName>
				<script>function roomItems()
if true then return end
  --display(gmcp.Room.Items)
  --print(item)
  local id, item = next(gmcp.Room.Items)
--print(id)
  if item == 9980 then
    print("Remove")
    return
  end
  if gmcp.Room.Items.All then
  brax.roomItems = {}
      brax.roomItems = table.update(brax.roomItems,gmcp.Room.Items.All)
    for i, v in pairs(gmcp.Room.Items.All) do
      local _, item = next(v)
      print(item.name)
    end
  end
end

registerAnonymousEventHandler("gmcp.Room.Items", "roomItems")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GitUpdater</name>
				<packageName></packageName>
				<script>function GitUpdater(event, ...)
  GitUpdate = GitUpdate or {}
  GitUpdate.repo = "https://github.com/tdk1069/EleUI2/releases/latest/download/"
  GitUpdate.versionFile = "version.txt"
  GitUpdate.packageFile = "EleUI2.mpackage"
  GitUpdate.downloadDoneID = registerAnonymousEventHandler("sysDownloadDone", "GitUpdater")
  GitUpdate.downloadErrorID = registerAnonymousEventHandler("sysDownloadError", "GitUpdater")
  GitUpdate.uninstallPackageID = registerAnonymousEventHandler("sysUninstallPackage", "GitUpdater")
  GitUpdate.localPath = getMudletHomeDir().."/settings/"

  if not io.exists(GitUpdate.localPath) then
    lfs.mkdir(GitUpdate.localPath)
  end

  if event == "sysDownloadDone" then
    local downloadFullFile = arg[1]
    local vFile = arg[1]:match(".*%/(.*%..*)$")

    if vFile == "version.txt" then
      local f, error, versiontxt = io.open(downloadFullFile)
      if f then
        versiontxt = f:read("*a");
        io.close(f)
      end
      local verNum = tonumber(versiontxt:match("Version: (.*)"))
      local thisVerNum = tonumber(brax.version:match("Version: (.*)"))
      cecho("&lt;cyan&gt;»»&lt;reset&gt;Online Version:&lt;yellow&gt;"..verNum.."\n")
      cecho("&lt;cyan&gt;»»&lt;reset&gt;Installed Version:&lt;yellow&gt;"..thisVerNum.."\n")
      
      if verNum &gt; thisVerNum then
        cecho("&lt;cyan&gt;»»&lt;reset&gt;Update Available (&lt;yellow&gt;"..versiontxt.."&lt;reset&gt;).. Downloading\n")
        if gmcp.Char.Status.name == "Brax" then
          cecho("&lt;red&gt;»»&lt;reset&gt;Blocking Update on Dev Profile!&lt;red&gt;««&lt;reset&gt;\n")
          return
        else
          downloadFile(GitUpdate.localPath..GitUpdate.packageFile,GitUpdate.repo..GitUpdate.packageFile)
        end
      else
        cecho("&lt;cyan&gt;»»&lt;reset&gt;No update available&lt;reset&gt;\n")
      end
    elseif vFile == "EleUI2.mpackage" then -- end EleUI_version.txt download
      print("Update downloaded - Start uninstall")
      Adjustable.Container.saveAll()
      uninstallPackage("EleUI2")
    end 

  elseif event == "sysUninstallPackage" then
    if arg[1] == "EleUI2" then
      cecho("&lt;cyan&gt;»»&lt;reset&gt;Uninstalled: &lt;yellow&gt;"..arg[1].."\n")
      cecho("&lt;cyan&gt;»»&lt;reset&gt;Waiting  to install\n")
      
      installPackage(GitUpdate.localPath..GitUpdate.packageFile)
      tempTimer(5, [[ installPackage(GitUpdate.localPath..GitUpdate.packageFile) ]])
    end
  elseif event == "sysDownloadError" then
   cecho("&lt;red&gt;»»&lt;reset&gt;Download Error: "..arg[1].."\n")
  else
    cecho("&lt;cyan&gt;»»&lt;reset&gt;Checking for update&lt;reset&gt;\n")
    downloadFile(GitUpdate.localPath..GitUpdate.versionFile,GitUpdate.repo..GitUpdate.versionFile)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>chatBox</name>
				<packageName></packageName>
				<script>function incoming_tell()
  local tab = "Tell"
  local chat_msg = gmcp.Msg.Tell.msg
  local from = gmcp.Msg.Tell.from
  local to = gmcp.Msg.Tell.to
  if not table.contains(chatBox.consoles,tab) then
    chatBox:addTab(tab)
  end
  chatBox:cecho(tab,"&lt;red&gt;"..from.."&lt;reset&gt; &gt; &lt;red&gt;"..to.."&lt;reset&gt;: "..chat_msg.."\n")
  if brax.bell then playSoundFile(getMudletHomeDir()..[[/EleUI2/snd/FFXIV_Incoming_Tell_3.mp3]]) end
end

function incoming_channel()
  local tab = gmcp.Msg.Chat.channel
  local chat_msg = gmcp.Msg.Chat.msg
  local chat_who = gmcp.Msg.Chat.who
  local ansicol = "&lt;"..string.lower(string.match(gmcp.Msg.Chat.rawmsg,"^%%%^\(%a+)")).."&gt;"
  local boxMsg
  if not table.contains(chatBox.consoles,tab) then
    chatBox:addTab(tab)
  end
  if gmcp.Msg.Chat.emote &gt; 1 then
    chat_msg = chat_msg:match("%w*(.*)")
    boxMsg = ansicol.."["..chat_who.."]&lt;reset&gt;"..chat_msg:gsub("%%^.-%%^","").."\n"
  else
    if string.lower(chat_msg):find(string.lower(gmcp.Char.Status.name)) and brax.bell then playSoundFile(getMudletHomeDir()..[[/EleUI2/snd/FFXIV_Incoming_Tell_3.mp3]]) end
    boxMsg = ansicol.."["..chat_who.."]&lt;reset&gt; "..chat_msg:gsub("%%^.-%%^","").."\n"
  end
  chatBox:cecho(tab,boxMsg)
end

registerAnonymousEventHandler("gmcp.Msg.Chat", "incoming_channel")
registerAnonymousEventHandler("gmcp.Msg.Tell", "incoming_tell")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Buffs</name>
				<packageName></packageName>
				<script>function get_Buffs()
  myBuffs = myBuffs or {}
  myBuffsTotal = myBuffsTotal or 0
--  display(gmcp.Char.Buffs)
  for spell, dur in pairs(gmcp.Char.Buffs) do
    if dur ~= 0 then
      local debuff = gmcp.Char.Buffs[spell][3]
      local count = 0
      local frontCSS =
        [[
        border-style: outset;
        border-color: gray;
        border-width: 1px;
        border-radius: 4px;
        margin: 0px;
        padding: 0px;
        background-color: #1f6140;
]]
      if debuff == 1 then
        frontCSS =
          [[
    border-style: outset;
    border-color: gray;
    border-width: 1px;
    border-radius: 4px;
    margin: 0px;
    padding: 0px;
    background-color: #800000;
]]
      end
      local dupeFix = 99999
      for spell,dupecheck in pairs(myBuffs) do
        count = count + 1
        if dupecheck &gt;= dupeFix then dupeFix = dupecheck+1 end
      end
      myBuffsTotal = count - 1
      if dur[1] == 0 then 
        dur[1]=dupeFix
      end
      demonnic.anitimer:new(
        spell,
        {x = 0, y = myBuffsTotal * 25, height = 20, width = "100%"},
        dur[1],
        {container = buffBoxContainer, showTime = true, timerCaption = spell, cssFront = frontCSS}
      )
if dur[1] &gt;= 99999 then 
  demonnic.anitimer:pause(spell)
  demonnic.anitimer.timers[spell].gauge.text:echo([[&lt;span style="font-family: 'Game _Played';"&gt;]]..spell)
end
      demonnic.anitimer.timers[spell].gauge.text:setStyleSheet([[padding-left:2px]])
      demonnic.anitimer.timers[spell].gauge.text:setToolTip(dur[2])
      myBuffs[spell] = demonnic.anitimer.timers[spell].current
--hotbar
      for i = 1, 10 do
      brax.hotbar[i] = brax.hotbar[i] or {}
        if brax.hotbar[i].buff == spell then
          brax.hotbar[i].box:setStyleSheet(
            [[QLabel{background-color: red;border-width: 1px;border-style: solid;border-color: green;border-radius: 3px;}QLabel::hover {background-color:grey;}]]
          )
          --local css = [[QLabel{background-color: red;border-width: 1px;border-style: solid;border-color: green;border-radius: 3px;}]]
          tempTimer(
            dur[1],
            function()
              brax.hotbar[i].box:setStyleSheet(
                [[QLabel{background-color: black;border-width: 1px;border-style: solid;border-color: green;border-radius: 3px;}]]
              )
            end
          )
        end
      end
--end hotbar
    else
      demonnic.anitimer.timers[spell].gauge:hide()
      myBuffs[spell] = null
      demonnic.anitimer:destroy(spell)
      local count = 0
      for _ in pairs(myBuffs) do
        count = count + 1
      end
      myBuffsTotal = count
    end
  end
  local tBuff = {}
  local tName = {}
  local pos = 0
  local timeLeft = 0
  for i, v in pairs(myBuffs) do
    timeLeft = demonnic.anitimer.timers[i].current
    table.insert(tBuff, timeLeft)
    tName[timeLeft] = i
  end
  table.sort(tBuff)
  for i, v in pairs(tBuff) do
    demonnic.anitimer.timers[tName[v]].gauge:move(0, pos * 25)
    pos = pos + 1
  end
end

registerAnonymousEventHandler("gmcp.Char.Buffs", "get_Buffs")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Cooldowns</name>
				<packageName></packageName>
				<script>function get_Cooldowns()

  myCooldowns = myCooldowns or {}
  myCooldownsTotal =   myCooldownsTotal or 0

--display(gmcp.Char.Cooldowns)

  local count = 0
  for spell,dur in pairs(gmcp.Char.Cooldowns) do
    if dur ~= 0 then
      local count = 0
      local frontCSS = [[
        border-style: outset;
        border-color: gray;
        border-width: 1px;
        border-radius: 4px;
        margin: 0px;
        padding: 0px;
        background-color: #1f6140;
]]
      for _ in pairs(myCooldowns) do count = count + 1 end
      myCooldownsTotal = count -1
      demonnic.anitimer:new("cd"..spell, {x = 0, y=myCooldownsTotal*25, height = 20, width = "100%"}, dur, {container = cooldownBoxContainer, showTime = true, timerCaption = spell,cssFront=frontCSS,hook = "aTimerEnd(\""..spell.."\")"})
      if cooldownBoxContainer.hidden == true then 
        demonnic.anitimer.timers["cd"..spell].gauge:hide(true) 
      else
        demonnic.anitimer.timers["cd"..spell].gauge:show() 
      end
      myCooldowns[spell] = demonnic.anitimer.timers["cd"..spell].current
    else 
--      if demonnic.anitimer.timers["cd"..spell] then demonnic.anitimer.timers["cd"..spell].gauge:hide() end
      myCooldowns["cd"..spell] = null
      demonnic.anitimer:destroy("cd"..spell)
    end
  end
  
  local count = 0
  for _ in pairs(myCooldowns) do count = count + 1 end
  myCooldownsTotal = count

  local tCooldowns = {}
  local tName = {}
  local pos = 0
  local timeLeft = 0
  for i,v in pairs(myCooldowns) do 
    if demonnic.anitimer.timers["cd"..i] then
      timeLeft = demonnic.anitimer.timers["cd"..i].current
      table.insert(tCooldowns,timeLeft)
      tName[timeLeft]=i
    end
  end
  table.sort(tCooldowns)
  for i,v in pairs(tCooldowns) do 
    demonnic.anitimer.timers["cd"..tName[v]].gauge:move(0,pos*25)
    pos = pos +1
  end

end

registerAnonymousEventHandler("gmcp.Char.Cooldowns","get_Cooldowns")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Body</name>
				<packageName></packageName>
				<script>function get_Body()
  myLimbs = myLimbs or {}
  for limb,details in pairs(gmcp.Char.Limbs) do
    myLimbs[limb] = myLimbs[limb] or {}
    if gmcp.Char.Limbs[limb] == "number" then
      gmcp.Char.Limbs[limb].maxhp = gmcp.Char.Limbs[limb]
      gmcp.Char.Limbs[limb].hp = gmcp.Char.Limbs[limb].hp
      gmcp.Char.Limbs[limb].severed = 0
      gmcp.Char.Limbs[limb].bandaged = 0
    end
    if gmcp.Char.Limbs[limb].hp == 0 and gmcp.Char.Limbs[limb].severed == 0 and gmcp.Char.Limbs[limb].bandaged == 0 then
      myLimbs[limb] = nil
    end
    gmcp.Char.Limbs = gmcp.Char.Limbs or {}
    if gmcp.Char.Limbs[limb].hp then myLimbs[limb].hp = gmcp.Char.Limbs[limb].hp or details.hp end
    if gmcp.Char.Limbs[limb].maxhp then myLimbs[limb].maxhp = gmcp.Char.Limbs[limb].maxhp or details.maxhp end
    if gmcp.Char.Limbs[limb].severed then myLimbs[limb].severed = gmcp.Char.Limbs[limb].severed or details.severed end
    if gmcp.Char.Limbs[limb].bandaged then myLimbs[limb].bandaged = gmcp.Char.Limbs[limb].bandaged or details.bandaged end
    if myLimbs[limb].hp and myLimbs[limb].maxhp then
      myLimbs[limb].pc = 100 - math.ceil((myLimbs[limb].hp/myLimbs[limb].maxhp)*100)
    end
  end

  tempLimb = {}
  for limb,details in pairs(myLimbs) do
    tempLimb[limb] = details.pc
  end
  list = {}
  for name,value in pairs(tempLimb) do
  	list[#list+1] = name
  end
  function byval(a,b)
  	return tempLimb[a] &gt; tempLimb[b]
  end
  table.sort(list,byval)
  local bodyString = "&lt;table&gt;"
  for k=1,#list do
        bodyString = bodyString .. "&lt;tr&gt;&lt;td width='50%'&gt;".. list[k] .. "&lt;/td&gt;&lt;td&gt;" .. tempLimb[list[k]] .. "&lt;/td&gt;&lt;td&gt;"..("#"):rep(math.ceil(tempLimb[list[k]]/10)).."&lt;/td&gt;&lt;/tr&gt;"
  end
  bodyBox:echo(bodyString)
end

registerAnonymousEventHandler("gmcp.Char.Limbs","get_Body")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>helpers</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
function aTimerEnd(spell)
  local timer = timer or ""
  if myCooldowns[spell] then 
    myCooldowns[spell] = nil
    demonnic.anitimer:destroy("cd"..spell)
  end 
local tCooldowns = {}
  local tName = {}
  local pos = 0
  local timeLeft = 0
  for i,v in pairs(myCooldowns) do 
  if demonnic.anitimer.timers["cd"..i] then
    timeLeft = demonnic.anitimer.timers["cd"..i].current
    table.insert(tCooldowns,timeLeft)
    tName[timeLeft]=i
  end
  end
  table.sort(tCooldowns)
  for i,v in pairs(tCooldowns) do 
    demonnic.anitimer.timers["cd"..tName[v]].gauge:move(0,pos*25)
    pos = pos +1
  end
end

function toggleBox(uiElement)
  if uiElement.hidden == true then
    uiElement:show()
  else
    uiElement:hide()
  end
  do_Config()
end

function saveWindows()
  Adjustable.Container.saveAll()
  cecho("&lt;cyan&gt;»»&lt;reset&gt;Layout Saved&lt;cyan&gt;««&lt;reset&gt;\n")
end

function loadWindows()
  Adjustable.Container.loadAll()
  cecho("&lt;cyan&gt;»»&lt;reset&gt;Layout Restored&lt;cyan&gt;««&lt;reset&gt;\n")
end

function SecondsToClock(seconds)
  local seconds = tonumber(seconds)
  if seconds &lt;= 0 then
    return "00:00";
  else
    hours = string.format("%02.f", math.floor(seconds/3600));
    mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)));
    secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60));
    return mins..":"..secs
  end
end

function properCase(str)
  return string.gsub(" "..str, "%W%l", string.upper):sub(2)
end

function ui_Theme(theme)
  local adjLabelstyle
  adjLabelstyle = adjLabelstyle or [[
      background-color: rgba(0,0,0,100%);
      border: 4px double ]]..theme..[[;
      border-radius: 4px;]]
  adjLabelstyle = adjLabelstyle..[[ qproperty-alignment: 'AlignLeft | AlignTop';]]
--  adjLabelstyle = [[border: 6px solid transparent;border-image: url(C:/Users/tdk10/.config/mudlet/profiles/Brax/EleUI2/imgs/oga.png) round]]
  cont = cont or Geyser
  for  k,v in pairs(cont.windowList) do
    if v.type == "adjustablecontainer" then 
      v.adjLabel:setStyleSheet(adjLabelstyle)
    end
    Adjustable.Container.saveAll(v)
  end

end

function Geyser.Label:setCooldown(params)
    self.start = params.start or 0 --start value of stylesheet variable
    self.stop = params.stop or 1 -- stop value of stylesheet variable
    self.cval = params.start -- current value of stylesheet variable (dynamic)
    self.cdStyleSheet = params.styleSheet --stylesheet has %s in place of dynamic value
    self.framerate = params.framerate or 0.05 -- framerate as decimal: default 20fps
    self.cd_label = Geyser.Label:new({
        name = self.name_cd_label,
        x = 0,
        y = 0,
        height = '100%',
        width = '100%',
    }, self)
    self.cd_label:hide()
    
end

function Geyser.Label:startCooldown(time)
    self.time = time or 1
    self.increment = self.framerate / self.time
    self.cval = self.start
    self.cd_label:show()
    self.cd_label:setStyleSheet(string.format(self.cdStyleSheet, tostring(self.cval)))
    if self.cdtimer then killTimer(self.cdtimer) end

    self.cdtimer = tempTimer(self.framerate, function()
        self.cval = self.cval + self.increment 
        if self.cval &gt;= self.stop then
            self:stopCooldown()
        else
            self.cd_label:setStyleSheet(string.format(self.cdStyleSheet, tostring(self.cval)))
        end
    end,
    true --timer is repeating
    )
end

function Geyser.Label:stopCooldown()
    self.cval = self.start
    self.cd_label:setStyleSheet(string.format(self.cdStyleSheet, tostring(self.cval)))
    self.cd_label:hide()
    killTimer(self.cdtimer)
end

brax.CDripple = [[
	background-color: qradialgradient(
		spread:pad, cx:0.5, cy:0.5, radius:%s, fx:0.5, fy:0.5, 
		stop:0.3 rgba(100, 100, 100, 180), 
		stop:0.6 rgba(100, 100, 100, 130), 
		stop:0.7 rgba(120, 120, 120, 0))
    ]]
brax.qconical = [[background-color: qconicalgradient(cx:0.5, cy:0.5, angle:90, stop:%s rgba(0, 0, 0, 200), stop:1 rgba(255, 255, 255, 0))]]
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>PartyStuff</name>
				<packageName></packageName>
				<script>function do_Party()
  if gmcp.Party.Members == {} then 
    brax.party.Members = {}
  else
--  display(gmcp.Party.Members)
    brax.party.Members = gmcp.Party.Members
  end
  if next(gmcp.Party.Members) == {} then brax.party.Members[next(gmcp.Party.Members)] = nil end
  getParty()
end

function do_Party_Vitals()
  brax.party.Vitals = table.update(brax.party.Vitals,gmcp.Party.Vitals)
  getParty()
end

function testParty()
--display(gmcp.Party)
end

function getParty()
  local details = "&lt;table&gt;&lt;tr&gt;&lt;th align='left'&gt;&lt;/th&gt;&lt;th align='left'&gt;HP&lt;/th&gt;&lt;th align='left'&gt;MP&lt;/th&gt;&lt;th align='left'&gt;SP&lt;/th&gt;&lt;/tr&gt;"
  for i,v in pairs(brax.party.Members) do 
    brax.party.Vitals[i] = brax.party.Vitals[i] or {}
    brax.party.Vitals[i].hp = brax.party.Vitals[i].hp or 0
    brax.party.Vitals[i].mp = brax.party.Vitals[i].mp or 0
    brax.party.Vitals[i].sp = brax.party.Vitals[i].sp or 0
    details = details.."&lt;tr&gt;&lt;td width='25%'&gt;"..properCase(i).."&lt;/td&gt;&lt;td width='25%'&gt;"..colStat(brax.party.Vitals[i].hp).."&lt;/td&gt;&lt;td width='25%'&gt;"..colStat(brax.party.Vitals[i].mp).."&lt;/td&gt;&lt;td width='25%'&gt;"..colStat(brax.party.Vitals[i].sp).."&lt;/td&gt;&lt;/tr&gt;"
  end
  partyBox:echo(details)
end

function colStat(value)
  local stat = math.floor(value*100)
  local colour = ""
  if stat &lt; 33 then
    colour = "red"
  elseif stat &lt; 66 then
    colour = "yellow"
  else
    colour = "lightgreen"
  end
  return "&lt;span style='color:"..colour..";'&gt;"..stat.."%&lt;/span&gt;"
end

registerAnonymousEventHandler("gmcp.Party.Members","do_Party")
registerAnonymousEventHandler("gmcp.Party.Vitals","do_Party_Vitals")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Casting Bar</name>
				<packageName></packageName>
				<script>function castBar()
  if gmcp.Char.Cast.cast_time &gt; 0 then
    demonnic.anitimer:new("cast_"..gmcp.Char.Cast.spell, {x = 0, y=0, height = "100%", width = "100%"}, gmcp.Char.Cast.cast_time, {container = castbarBoxContainer, showTime = true, timerCaption = gmcp.Char.Cast.spell})
      if castbarBoxContainer.hidden == true then 
        demonnic.anitimer.timers["cast_"..gmcp.Char.Cast.spell].gauge:hide(true) 
      else
        demonnic.anitimer.timers["cast_"..gmcp.Char.Cast.spell].gauge:show() 
      end
  else
    demonnic.anitimer:destroy("cast_"..gmcp.Char.Cast.spell)
  end
end

registerAnonymousEventHandler("gmcp.Char.Cast", "castBar")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Routes</name>
				<packageName></packageName>
				<script>function uiRoutes(index)
  local path = ""
  local route = {}
  if io.exists(getMudletHomeDir().."/settings/Routes.lua") then
    table.load(getMudletHomeDir().."/settings/Routes.lua",route)
  end
  local menuIndex = tonumber(index)
  if index == "add" then
    table.insert(route, {id = getRoomHashByID(eleMap.currentRoom), name = getRoomName(eleMap.currentRoom)})
    table.save(getMudletHomeDir().."/settings/Routes.lua",route)
  elseif menuIndex == nil then
    decho(
      "&lt;128,0,128&gt;\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"
    )
    for i, v in pairs(route) do
      print(i .. ") " .. v.name)
    end
    decho(
      "&lt;128,0,128&gt;\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n"
    )
  else
    if route[tonumber(index)].id then
      if
        getPath(getRoomIDbyHash(gmcp.Room.Id), getRoomIDbyHash(route[tonumber(index)].id))
      then
        brax.STOP = false
        if #speedWalkDir == 0 then return end
        speedwalktimer(speedWalkDir, brax.speedwalkDelay , false)
      else
        decho("Unable to find a path there!\n")
      end
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>setBorders</name>
				<packageName></packageName>
				<script>function setBorders(type)
  type = type:lower() or ""
  brax.left_container = brax.left_container or Geyser.Container:new({
    name = "brax.left_container",
    x=0, y=0,
    width = 0, height="100%",
  })
  brax.left_image = brax.left_image or Geyser.Label:new({
    name = "brax.left_image",
    x = "0%", y = "0%",
    width = "100%", height = "100%",
  },brax.left_container)
  brax.left_image:setBackgroundImage(getMudletHomeDir().."/imgs/texture.jpg")
  brax.left_container:hide()
  brax.right_container = brax.right_container or Geyser.Container:new({
    name = "brax.right_container",
    x=0, y=0,
    width = 0, height="100%",
  })
  brax.right_image = brax.right_image or Geyser.Label:new({
    name = "brax.right_image",
    x = "0%", y = "0%",
    width = "100%", height = "100%",
  },brax.right_container)
  brax.right_image:setBackgroundImage(getMudletHomeDir().."/imgs/texture.jpg")
  brax.right_container:hide()
  
  local fx, fy = calcFontSize()
  local winx, winy = getMainWindowSize()
  local newBorder = winx - fx*80
  if type == "right" then 
    brax.right_container:hide()
    brax.left_container:show()
    brax.left_container:resize(newBorder,nil)
    brax.left_container:move(winx-newBorder,nil)
    brax.left_image:lower()
    setBorderRight(newBorder) 
    setBorderLeft(0) 
  elseif type == "left" then 
    brax.left_container:hide()
    brax.right_container:show()
    brax.right_container:resize(newBorder,nil)
    brax.right_container:move(0,nil)
    brax.right_image:lower()
    setBorderLeft(newBorder) 
    setBorderRight(0) 
  elseif type == "center" then 
    setBorderLeft(newBorder/2) 
    setBorderRight(newBorder/2) 
    brax.right_container:resize(newBorder/2,nil)
    brax.right_container:move(0,nil)
    brax.left_container:resize(winx-newBorder + (newBorder/2),nil)
    brax.left_container:move(0,nil)
    brax.right_container:show()
    brax.left_container:show()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>overrides</name>
				<packageName></packageName>
				<script>function json_to_value(eledata)
--display(eledata)
  if string.find(eledata,"^%d*$") then
    return tonumber(eledata)
  elseif eledata:sub(3,5) == "msg" then
    msg = {string.match(eledata,'{\"(.-)\": \"(.-)\", \"(.-)\": \"(.-)\", \"(.-)\": \"(.-)\", \"(.-)\": \"(.-)\", \"(%a-)\": \"(.-)\"}')}
    return yajl.to_value((string.format("{\"%s\": %q, \"%s\": \"%s\", \"%s\": \"%s\", \"%s\": %q, \"%s\": \"%s\" }",msg[1],msg[2],msg[3],msg[4],msg[5],msg[6],msg[7],msg[8],msg[9],msg[10])))
  elseif eledata:sub(3,7) == "emote" then
    msg = {string.match(eledata,'{\"(%a-)\": (%d-), \"(%a-)\": \" (.-)\", \"(%a-)\": \"(%a-)\", \"(%a-)\": \"(.-)\", \"rawmsg\": \"(.*)\"')}
    return yajl.to_value((string.format("{\"%s\": %d, \"%s\": \"%s\", \"%s\": \"%s\", \"%s\": %q, \"rawmsg\": %q }",msg[1],msg[2],msg[3],msg[4],msg[5],msg[6],msg[7],msg[8],msg[9])))
  else
    return yajl.to_value(eledata)
  end
end

function speedwalktimer(walklist, walkdelay, show)
  if getDoors(eleMap.currentRoom)[walklist[1]] then 
    send(getRoomUserData(eleMap.currentRoom,"Exit_"..walklist[1])) 
  end
  send(walklist[1], show)
  table.remove(walklist, 1)
  if brax.STOP == true then walklist = {} end
  if #walklist &gt; 0 then
    local spFudge = 1-(gmcp.Char.Vitals.sp/gmcp.Char.Vitals.maxsp)
    if spFudge&gt;0.95 then spFudge = spFudge + 0.3 end  
    tempTimer(walkdelay+spFudge, function()
    speedwalktimer(walklist, walkdelay, show)
    end)
  end
end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>AnimatedTimers</name>
				<packageName>AnimatedTimers</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>code</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.anitimer = demonnic.anitimer or {}
demonnic.anitimer.timers = demonnic.anitimer.timers or {}
demonnic.anitimer.activeTimers = demonnic.anitimer.activeTimers or {}

function demonnic.anitimer:new(name, cons, time, options)
  if options and type(options) ~= "table" then
    error("demonnic.anitimer:new() -- if you provide a fourth parameter, it must be a table. Please see http://github.com/demonnic/animatedtimers for detailed usage information")
  end
  if not options then
    options = {}
  end
  if options.showTime == nil then options.showTime = true end 
  options.timerCaption = options.timerCaption or ""

  if not demonnic.anitimer.timers[name] then
    demonnic.anitimer.timers[name] = {}
    demonnic.anitimer.timers[name].gauge = Geyser.Gauge:new(cons, options.container)
    demonnic.anitimer.timers[name].watch = createStopWatch()
  else
    for k,v in pairs(cons) do
      demonnic.anitimer.timers[name].gauge[k] = v
    end
    if options.container then
      options.container:add(demonnic.anitimer.timers[name].gauge)
    else
      Geyser:add(demonnic.anitimer.timers[name].gauge)
    end
  end
    demonnic.anitimer.timers[name].max = time
    demonnic.anitimer.timers[name].current = time
    demonnic.anitimer.timers[name].showTime = options.showTime
    demonnic.anitimer.timers[name].timerCaption = options.timerCaption
		demonnic.anitimer.timers[name].hook = options.hook
    if options.cssFront then
      if not options.cssBack then
        options.cssBack = options.cssFront .. "background-color: black;"
      end
      demonnic.anitimer.timers[name].gauge:setStyleSheet(options.cssFront, options.cssBack)
    end
    if not table.contains(demonnic.anitimer.activeTimers, name) then table.insert(demonnic.anitimer.activeTimers, name) end
    resetStopWatch(demonnic.anitimer.timers[name].watch)
    startStopWatch(demonnic.anitimer.timers[name].watch)
    demonnic.anitimer:update(name)
end

function demonnic.anitimer:getTime(name)
  if not demonnic.anitimer.timers[name] then return 0 end
  local max = demonnic.anitimer.timers[name].max
  local current = getStopWatchTime(demonnic.anitimer.timers[name].watch)
  local newValue = max - current
  return newValue
end

function demonnic.anitimer:showTimers()
  cecho("&lt;yellow&gt;List of animated timers which have been created")
  for timer,_ in pairs(demonnic.anitimer.timers) do
    cecho(string.format("   %s", timer))
  end
  local actives = ""
  for _,timer in ipairs(demonnic.anitimer.activeTimers) do
    if actives == "" then
      actives = timer
    else
      actives = string.format("%s, %s", actives, timer)
    end
  end
  cecho("&lt;yellow&gt;Active timers: &lt;red&gt;" .. actives)
end

function demonnic.anitimer:update(name)
  if not demonnic.anitimer.timers[name] then return nil end
  demonnic.anitimer.timers[name].current = demonnic.anitimer:getTime(name)
  local time = demonnic.anitimer.timers[name].current
  demonnic.anitimer.timers[name].text = [[&lt;span style="font-family: 'Game Pldayed';"&gt;]]..(demonnic.anitimer.timers[name].showTime and string.format("%.0f %s", time, demonnic.anitimer.timers[name].timerCaption or "")) or (demonnic.anitimer.timers[name].timerCaption or "")
  demonnic.anitimer.timers[name].text = [[&lt;span style="font-family: 'Game _Played';"&gt;]]..(demonnic.anitimer.timers[name].showTime and string.format("%s %s", SecondsToClock(time), demonnic.anitimer.timers[name].timerCaption or "")) or (demonnic.anitimer.timers[name].timerCaption or "")
  demonnic.anitimer.timers[name].gauge:setValue(demonnic.anitimer.timers[name].current, demonnic.anitimer.timers[name].max, demonnic.anitimer.timers[name].text)
end

function demonnic.anitimer:stop(name)
  if not demonnic.anitimer.timers[name] then return nil end
  stopStopWatch(demonnic.anitimer.timers[name].watch)
  demonnic.anitimer.timers[name].gauge:hide()
  for i,v in pairs(demonnic.anitimer.activeTimers) do
    if demonnic.anitimer.timers[v] == demonnic.anitimer.timers[name] then
      table.remove(demonnic.anitimer.activeTimers, i)
      return
    end
  end
end

function demonnic.anitimer:stopAll()
  for _,name in pairs(demonnic.anitimer.activeTimers) do
    demonnic.anitimer:stop(name)
  end
end

function demonnic.anitimer:pause(name)
  if not demonnic.anitimer.timers[name] then return nil end
  stopStopWatch(demonnic.anitimer.timers[name].watch)
  for i,v in pairs(demonnic.anitimer.activeTimers) do
    if v == name then
      table.remove(demonnic.anitimer.activeTimers, i)
      return
    end
  end
end

function demonnic.anitimer:pauseAll()
  for name,_ in pairs(demonnic.anitimer.timers) do
    demonnic.anitimer:pause(name)
  end
end

function demonnic.anitimer:destroy(name)
  if not demonnic.anitimer.timers[name] then return nil end
  demonnic.anitimer:stop(name)
  demonnic.anitimer.timers[name] = nil
  return true
end

function demonnic.anitimer:destroyAll()
  for name,_ in pairs(demonnic.anitimer.timers) do
    demonnic.anitimer:destroy(name)
  end
end

function demonnic.anitimer:start(name)
  if not demonnic.anitimer.timers[name] then return nil end
  local current = demonnic.anitimer.timers[name].current
  if current == 0 then return nil end
  demonnic.anitimer.timers[name].max = current
  resetStopWatch(demonnic.anitimer.timers[name].watch)
  startStopWatch(demonnic.anitimer.timers[name].watch)
  if not table.contains(demonnic.anitimer.activeTimers, name) then table.insert(demonnic.anitimer.activeTimers, name) end
  demonnic.anitimer.timers[name].gauge:show()
  demonnic.anitimer:update(name)
end

function demonnic.anitimer:startAll()
  for name,_ in pairs(demonnic.anitimer.timers) do
    if not table.contains(demonnic.anitimer.activeTimers, name) then
      demonnic.anitimer:start(name)
    end
  end
end

function demonnic.anitimer:animate()
  for i,v in pairs(demonnic.anitimer.activeTimers) do
    name = v
    demonnic.anitimer:update(name)
    if demonnic.anitimer:getTime(name) &lt;= 0 then
      demonnic.anitimer.timers[name].gauge:hide()
      table.remove(demonnic.anitimer.activeTimers, i)
      stopStopWatch(demonnic.anitimer.timers[name].watch)
      demonnic.anitimer.timers[name].max = 0
      demonnic.anitimer.timers[name].current = 0
			demonnic.anitimer:executeHook(name)
    end
  end
end

function demonnic.anitimer:executeHook(name)
  local hook = demonnic.anitimer.timers[name].hook
	local r = ""
	if hook == nil then
	  return
	elseif type(hook) == "string" then
	  local f,e = loadstring("return " .. hook)
		if not f then
		  f,e = assert(loadstring(hook))
		end
		f()
	elseif type(hook) == "function" then
	  hook()
	else
	  error("AnimatedTimers: you've provided a hook for " .. name .. " which is neither a string nor a function. Unable to execute")
	end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>EMCO</name>
				<packageName>EMCO</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>EMCO</name>
					<packageName></packageName>
					<script>--- Embeddable Multi Console Object.
-- This is essentially YATCO, but with some tweaks, updates, and it returns an object
-- similar to Geyser so that you can a.) have multiple of them and b.) easily embed it
-- into your existing UI as you would any other Geyser element.
-- @module EMCO
EMCO = Geyser.Container:new({
  name = "TabbedConsoleClass",
})

function EMCO:readYATCO()
  local config
  if demonnic and demonnic.chat and demonnic.chat.config then
    config = demonnic.chat.config
  else
    cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Could not find demonnic.chat.config, nothing to convert\n")
    return
  end
  local constraints = "EMCO:new({\n"
  constraints = string.format("%s  x = %d,\n", constraints, demonnic.chat.container.get_x())
  constraints = string.format("%s  y = %d,\n", constraints, demonnic.chat.container.get_y())
  constraints = string.format("%s  width = %d,\n", constraints, demonnic.chat.container.get_width())
  constraints = string.format("%s  height = %d,\n", constraints, demonnic.chat.container.get_height())
  if config.timestamp then
    constraints = string.format("%s  timestamp = true,\n  timestampFormat = \"%s\",\n", constraints, config.timestamp)
  else
    constraints = string.format("%s  timestamp = false,\n", constraints)
  end
  if config.timestampColor then
    constraints = string.format("%s  customTimestampColor = true,\n", constraints)
  else
    constraints = string.format("%s  customTimestampColor = false,\n", constraints)
  end
  if config.timestampFG then
    constraints = string.format("%s  timestampFGColor = \"%s\",\n", constraints, config.timestampFG)
  end
  if config.timestampBG then
    constraints = string.format("%s  timestampBGColor = \"%s\",\n", constraints, config.timestampBG)
  end
  if config.channels then
    local channels = "consoles = {\n"
    for _,channel in ipairs(config.channels) do
      if _ == #config.channels then
        channels = string.format("%s    \"%s\"", channels, channel)
      else
        channels = string.format("%s    \"%s\",\n", channels, channel)
      end
    end
    channels = string.format("%s\n  },\n", channels)
    constraints = string.format([[%s  %s]], constraints, channels)
  end
  if config.Alltab then
    constraints = string.format("%s  allTab = true,\n", constraints)
    constraints = string.format("%s  allTabName = \"%s\",\n", constraints, config.Alltab)
  else
    constraints = string.format("%s  allTab = false,\n", constraints)
  end
  if config.Maptab and config.Maptab ~= "" then
    constraints = string.format("%s  mapTab = true,\n", constraints)
    constraints = string.format("%s  mapTabName = \"%s\",\n", constraints, config.Maptab)
  else
    constraints = string.format("%s  mapTab = false,\n", constraints)
  end
  constraints = string.format("%s  blink = %s,\n", constraints, tostring(config.blink))
  constraints = string.format("%s  blinkFromAll = %s,\n", constraints, tostring(config.blinkFromAll))
  if config.fontSize then
    constraints = string.format("%s  fontSize = %d,\n", constraints, config.fontSize)
  end
  constraints = string.format("%s  preserveBackground = %s,\n", constraints, tostring(config.preserveBackground))
  constraints = string.format("%s  gag = %s,\n", constraints, tostring(config.gag))
  constraints = string.format("%s  activeTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.activeColors.r, config.activeColors.g, config.activeColors.b)
  constraints = string.format("%s  inactiveTabBGColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.inactiveColors.r, config.inactiveColors.g, config.inactiveColors.b)
  constraints = string.format("%s  consoleColor = \"&lt;%s,%s,%s&gt;\",\n", constraints, config.windowColors.r, config.windowColors.g, config.windowColors.b)
  constraints = string.format("%s  activeTabFGColor = \"%s\",\n", constraints, config.activeTabText)
  constraints = string.format("%s  inactiveTabFGColor = \"%s\"", constraints, config.inactiveTabText)
  constraints = string.format("%s\n})", constraints)
  return constraints
end

--- Scans for the old YATCO configuration values and prints out a set of constraints to use.
-- with EMCO to achieve the same effect. Is just the invocation
function EMCO:miniConvertYATCO()
  local constraints = self:readYATCO()
  cecho("&lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Here are the constraints to use with EMCO(x,y,width, and height have been converted to their absolute values):\n\n")
  echo(constraints .. "\n")
end

--- Echos to the main console a script object you can add which will fully convert YATCO to EMCO.
-- This replaces the demonnic.chat variable with a newly created EMCO object, so that the main
-- functions used to place information on the consoles (append(), cecho(), etc) should continue to
-- work in the user's triggers and events.
function EMCO:convertYATCO()
  local invocation = self:readYATCO()
  local header = [[
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Found a YATCO config. Make a new script, then copy and paste the following output into it.
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; Afterward, uninstall YATCO (you can leave YATCOConfig until you're sure everything is right) and restart Mudlet
  &lt;white&gt;(&lt;blue&gt;EMCO&lt;white&gt;)&lt;reset&gt; If everything looks right, you can uninstall YATCOConfig. 


-- Copy everything below this line until the next line starting with --
demonnic = demonnic or {}
demonnic.chat = ]]
  cecho(string.format("%s%s\n--- End script\n", header, invocation))
end

function EMCO:checkTabPosition(position)
  if position == nil then
    return 0
  end
  return tonumber(position) or type(position)
end

function EMCO:checkTabName(tabName)
  if not tostring(tabName) then
    return "tabName as string expected, got" .. type(tabName)
  end
  tabName = tostring(tabName)
  if table.contains(self.consoles, tabName) then
    return "tabName must be unique, and we already have a tab named " .. tabName
  else
    return "clear"
  end
end

function EMCO.ae(funcName, message)
  error(string.format("%s: Argument Error: %s", funcName, message))
end

function EMCO:ce(funcName, message)
  error(string.format("%s:gg Constraint Error: %s", funcName, message))
end

--- Adds a tab to the EMCO object
-- @tparam string tabName the name of the tab to add
-- @tparam[opt] number position position in the tab switcher to put this tab
function EMCO:addTab(tabName, position)
  local funcName = "EMCO:addTab(tabName, position)"
  position = self:checkTabPosition(position)
  if type(position) == "string" then self.ae(funcName, "position as number expected, got " .. position) end
  local tabCheck = self:checkTabName(tabName)
  if tabCheck ~= "clear" then self.ae(funcName, tabCheck) end
  if position == 0 then
    table.insert(self.consoles, tabName)
    self:createComponentsForTab(tabName)
  else
    table.insert(self.consoles, position, tabName)
    self:reset()
  end
end

function EMCO:switchTab(tabName)
  local oldTab = self.currentTab
  if oldTab ~= tabName and oldTab ~= "" then
    self.mc[oldTab]:hide()
    self.tabs[oldTab]:setStyleSheet(self.inactiveTabCSS)
    self.tabs[oldTab]:setColor(self.inactiveTabBGColor)
    self.tabs[oldTab]:echo(oldTab, self.inactiveTabFGColor, "c")
    if self.blink then
      if self.allTab and tabName == self.allTabName then
        self.tabsToBlink = {}
      elseif self.tabsToBlink[tabName] then
        self.tabsToBlink[tabName] = nil
      end
    end
  end
  self.tabs[tabName]:setStyleSheet(self.activeTabCSS)
  self.tabs[tabName]:setColor(self.activeTabBGColor)
  self.tabs[tabName]:echo(tabName, self.activeTabFGColor, "c")
  if oldTab and self.mc[oldTab] then
    self.mc[oldTab]:hide()
  end
  self.mc[tabName]:show()
  self.currentTab = tabName
end

function EMCO:createComponentsForTab(tabName)
  local tab = Geyser.Label:new({
    name = string.format("%sTab%s", self.name, tabName)
  }, self.tabBox)
  if self.tabFont then
    tab:setFont(tabFont)
  end
  tab:echo(tabName, self.inactiveTabFGColor, 'c')
  -- use the inactive CSS. It's "" if unset, which is ugly, but
  tab:setStyleSheet(self.inactiveTabCSS)
  -- set the BGColor if set. if the CSS is set it overrides the setColor, but if it's "" then the setColor actually covers that.
  -- and we set a default for the inactiveBGColor
  tab:setColor(self.inactiveTabBGColor)
  tab:setClickCallback("EMCOHelper.switchTab", nil, string.format("%s+%s",self.name, tabName))
  self.tabs[tabName] = tab
  local window
  local windowConstraints = {
    x = 1,
    y = 1,
    height = "-2px",
    width = "100%",
    name = string.format("%sWindow%s", self.name, tabName)
  }
  local parent = self.consoleContainer
  if self.mapTab and tabName == self.mapTabName then
    window = Geyser.Mapper:new(windowConstraints, parent)
  else
    window = Geyser.MiniConsole:new(windowConstraints, parent)
    if self.font then
      window:setFont(font)
    end
    window:setFontSize(self.fontSize)
    window:setColor(self.consoleColor)
    if self.autoWrap then
      window:enableAutoWrap()
    else
      window:setWrap(self.wrapAt)
    end
    if self.scrollbars then
      window:enableScrollBar()
    else
      window:disableScrollBar()
    end
  end
  self.mc[tabName] = window
  window:hide()
end

--- resets the object, redrawing everything
function EMCO:reset()
  self:createContainers()
  for _,tabName in ipairs(self.consoles) do
    self:createComponentsForTab(tabName)
  end
  local default
  if self.currentTab == "" then
    default = self.allTabName or self.consoles[1]
  else
    default = self.currentTab
  end
  self:switchTab(default)
end

function EMCO:createContainers()
  self.tabBoxLabel = Geyser.Label:new({
    x=0,
    y=0,
    width = "100%",
    height = tostring(tonumber(self.tabHeight) + 2) .. "px",
    name = self.name .. "TabBoxLabel"
  }, self)
  self.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "100%",
    name = self.name .. "TabBox"
  }, self.tabBoxLabel)
  self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
  self.tabBoxLabel:setColor(self.tabBoxColor)

  local heightPlusGap = tonumber(self.tabHeight) + tonumber(self.gap)
  self.consoleContainer = Geyser.Label:new({
    x = 0,
    y = tostring(heightPlusGap) .. "px",
    width = "100%",
    height = "-0px",
    name = self.name .. "ConsoleContainer"
  }, self)
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

function EMCO:stripTimeChars(str)
  return string.gsub(string.trim(str), '[hHmMszZaApPdy:. ]', '')
end

--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function EMCO:fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end

--- clears a specific tab
--- @tparam string tabName the name of the tab to clear
function EMCO:clear(tabName)
  local funcName = "EMCO:clear(tabName)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  if self.mapTab and self.mapTabName == tabName then
    self.ae(funcName, "Cannot clear the map tab")
  end
  self.mc[tabName]:clear()
end

--- clears all the tabs
function EMCO:clearAll()
  for _,tabName in ipairs(self.consoles) do
    if not self.mapTab or (tabName ~= self.mapTabName) then
      self:clear(tabName)
    end
  end
end

--- sets the font for all tabs
--- @tparam string font the font to use.
function EMCO:setTabFont(font)
  self.tabFont = font
  for _,tab in pairs(self.tabs) do
    tab:setFont(font)
  end
end

--- sets the font for a single tab. If you use setTabFont this will be overridden
--- @tparam string tabName the tab to change the font of
--- @tparam string font the font to use for that tab
function EMCO:setSingleTabFont(tabName, font)
  local funcName = "EMCO:setSingleTabFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  self.tabs[tabName]:setFont(font)
end

--- sets the font for all the miniconsoles
--- @tparam string font the name of the font to use
function EMCO:setFont(font)
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setFont(font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.font = font
  for _,tabName in pairs(self.consoles) do
    if not self.mapTab or tabName ~= self.mapTabName then
      self.mc[tabName]:setFont(font)
    end
  end
end

--- sets the font for a specific miniconsole. If setFont is called this will be overridden
--- @tparam string tabName the name of window to set the font for
--- @tparam string font the name of the font to use
function EMCO:setSingleWindowFont(tabName, font)
  local funcName = "EMCO:setSingleWindowFont(tabName, font)"
  if not table.contains(self.consoles, tabName) then
    self.ae(funcName, "tabName must be an existing tab")
  end
  local af = getAvailableFonts()
  if not (af[font] or font == "") then
    local err = "EMCO:setSingleWindowFont(tabName, font): attempt to call setFont with font '" .. font .. "' which is not available, see getAvailableFonts() for valid options\n"
    err = err .. "In the meantime, we will use a similar font which isn't the one you asked for but we hope is close enough"
    debugc(err)
  end
  self.mc[tabName]:setFont(font)
end

--- enables custom colors for the timestamp, if displayed
function EMCO:enableCustomTimestampColor()
  self.customTimestampColor = true
end

--- disables custom colors for the timestamp, if displayed
function EMCO:disableCustomTimestampColor()
  self.customTimestampColor = false
end

--- enables the display of timestamps
function EMCO:enableTimestamp()
  self.timestamp = true
end

--- disables the display of timestamps
function EMCO:disableTimestamp()
  self.timestamp = false
end

--- Sets the formatting for the timestamp, if enabled
-- @tparam string format Format string which describes the display of the timestamp. See: https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime
function EMCO:setTimestampFormat(format)
  local funcName = "EMCO:setTimestampFormat(format)"
  local strippedFormat = self:stripTimeChars(format)
  if strippedFormat ~= "" then
    self.ae(funcName, "format contains invalid time format characters. Please see https://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for formatting information")
  else
    self.timestampFormat = format
  end
end

--- Sets the background color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampBGColor(color)
  self.timestampBGColor = color
end
--- Sets the foreground color for the timestamp, if customTimestampColor is enabled.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTimestampFGColor(color)
  self.timestampFGColor = color
end

--- Sets the 'all' tab name.
-- &lt;br&gt;This is the name of the tab itself
-- @tparam string allTabName name of the tab to use as the all tab. Must be a tab which exists in the object.
function EMCO:setAllTabName(allTabName)
  local funcName = "EMCO:setAllTabName(allTabName)"
  local allTabNameType = type(allTabName)
  if allTabNameType ~= "string" then self.ae(funcName, "allTabName expected as string, got" .. allTabNameType) end
  if not table.contains(self.consoles, allTabName) then self.ae(funcName, "allTabName must be the name of one of the console tabs. Valid options are: " .. table.concat(self.containers, ",")) end
  self.allTabName = allTabName
end

--- Enables use of the 'all' tab
function EMCO:enableAllTab()
  self.allTab = true
end

--- Disables use of the 'all' tab
function EMCO:disableAllTab()
  self.allTab = false
end

--- Enables tying the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;mapTabName must be set, or this will error. Forces a redraw of the entire object
function EMCO:enableMapTab()
  local funcName = "EMCO:enableMapTab()"
  if not self.mapTabName then
    error(funcName .. ": cannot enable the map tab, mapTabName not set. try running :setMapTabName(mapTabName) first with the name of the tab you want to bind the map to")
  end
  self.mapTab = true
  self:reset()
end

--- disables binding the Mudlet Mapper to one of the tabs.
-- &lt;br&gt;CAUTION: this may have unexpected behaviour, as you can only open one Mapper console per profile
-- so you can't really unbind it. Binding of the Mudlet Mapper is best decided at instantiation.
function EMCO:disableMapTab()
  self.mapTab = false
end

--- sets the name of the tab to bind the Mudlet Map.
-- &lt;br&gt;Forces a redraw of the object
-- &lt;br&gt;CAUTION: Mudlet only allows one Map object to be open at one time, so if you are going to attach the map to an object
-- you should probably do it at instantiation.
-- @tparam string mapTabName name of the tab to connect the Mudlet Map to.
function EMCO:setMapTabName(mapTabName)
  local funcName = "EMCO:setMapTabName(mapTabName)"
  local mapTabNameType = type(mapTabName)
  if mapTabNameType ~= "string" then
    self.ae(funcName, "mapTabName as string expected, got" .. mapTabNameType)
  end
  if not table.contains(self.consoles, mapTabName) and mapTabName ~= "" then
    self.ae(funcName, "mapTabName must be one of the existing console tabs. Current tabs are: " .. table.concat(self.consoles, ","))
  end
  self.mapTabName = mapTabName
end

--- Enables tab blinking even if you're on the 'all' tab
function EMCO:enableBlinkFromAll()
  self.enableBlinkFromAll = true
end

--- Disables tab blinking when you're on the 'all' tab
function EMCO:disableBlinkFromAll()
  self.enableBlinkFromAll = false
end

--- Enables gagging of the line passed in to :append(tabName)
function EMCO:enableGag()
  self.gag = true
end

--- Disables gagging of the line passed in to :append(tabName)
function EMCO:disableGag()
  self.gag = false
end

--- Enables tab blinking when new information comes in to an inactive tab
function EMCO:enableBlink()
  self.blink = true
end

--- Disables tab blinking when new information comes in to an inactive tab
function EMCO:disableBlink()
  self.blink = false
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:enablePreserveBackground()
  self.preserveBackground = true
end

--- Enables preserving the chat's background over the background of an incoming :append()
function EMCO:disablePreserveBackground()
  self.preserveBackground = false
end

--- Sets how long in seconds to wait between blinks
-- @tparam number blinkTime time in seconds to wait between blinks
function EMCO:setBlinkTime(blinkTime)
  local funcName = "EMCO:setBlinkTime(blinkTime)"
  local blinkTimeNumber = tonumber(blinkTime)
  if not blinkTimeNumber then
    self.ae(funcName, "blinkTime as number expected, got ".. type(blinkeTime))
  else
    self.blinkTime = blinkTimeNumber
    if self.blinkTimerID then
      killTimer(self.blinkTimerID)
    end
    self.blinkTimerID = tempTimer(blinkTimeNumber, function() self:blink() end, true)
  end
end

function EMCO:doBlink()
  if self.hidden or self.auto_hidden or not self.blink then
    return
  end
  for tab,_ in pairs(self.tabsToBlink) do
    self.tabs[tab]:flash()
  end
end

--- Sets the font size of the attached consoles
-- @tparam number fontSize font size for attached consoles
function EMCO:setFontSize(fontSize)
  local funcName = "EMCO:setFontSize(fontSize)"
  local fontSizeNumber = tonumber(fontSize)
  local fontSizeType = type(fontSize)
  if not fontSizeNumber then
    self.ae(funcName, "fontSize as number expected, got " .. fontSizeType)
  else
    self.fontSize = fontSizeNumber
    for _,tabName in ipairs(self.consoles) do
      if self.mapTab and tabName == self.mapTabName then
        -- skip this one
      else
        local window = self.mc[tabName]
        window:setFontSize(fontSizeNumber)
      end
    end
  end
end

function EMCO:adjustTabNames()
  for _,console in ipairs(self.consoles) do
    if console == self.currentTab then
      self.tabs[console]:echo(console, self.activTabFGColor, 'c')
    else
      self.tabs[console]:echo(console, self.inactiveTabFGColor, 'c')
    end
  end
end

function EMCO:adjustTabBackgrounds()
  for _, console in ipairs(self.consoles) do
    local tab = self.tabs[console]
    if console == self.currentTab then
      tab:setStyleSheet(self.activeTabCSS)
      tab:setColor(self.activeBGColor)
    else
      tab:setStyleSheet(self.inactiveTabCSS)
      tab:setColor(self.inactiveBGColor)
    end
  end
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabFGColor(color)
  self.activeTabFGColor = color
  self:adjustTabNames()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabFGColor(color)
  self.inactiveTabFGColor = color
  self:adjustTabNames()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setActiveTabBGColor(color)
  self.activeTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setInactiveTabBGColor(color)
  self.inactiveTabBGColor = color
  self:adjustTabBackgrounds()
end

--- Sets the BG color for the consoles attached to this object
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleColor(color)
  self.consoleColor = color
  self:adjustConsoleColors()
end

function EMCO:adjustConsoleColors()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:setColor(self.consoleColor)
    end
  end
end

--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function EMCO:setTabBoxCSS(css)
  local funcName = "EMCHO:setTabBoxCSS(css)"
  local cssType = type(css)
  if cssType ~= "string" then
    self.ae(funcName, "css as string expected, got " .. cssType)
  else
    self.tabBoxCSS = css
    self:adjustTabBoxBackground()
  end
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setTabBoxColor(color)
  self.tabBoxColor = color
  self:adjustTabBoxBackground()
end

function EMCO:adjustTabBoxBackground()
    self.tabBoxLabel:setStyleSheet(self.tabBoxCSS)
    self.tabBoxLabel:setColor(self.tabBoxColor)
end

--- Sets the color for the container which holds the consoles attached to this object.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function EMCO:setConsoleContainerColor(color)
  self.consoleContainerColor = color
  self:adjustConsoleContainerBackground()
end

--- Sets the CSS to use for the container which holds the consoles attached to this object
-- @tparam string css CSS to use for the container
function EMCO:setConsoleContainerCSS(css)
  self.consoleContainerCSS = css
  self:adjustConsoleContainerBackground()
end

function EMCO:adjustConsoleContainerBackground()
  self.consoleContainer:setStyleSheet(self.consoleContainerCSS)
  self.consoleContainer:setColor(self.consoleContainerColor)
end

--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function EMCO:setGap(gap)
  local gapNumber = tonumber(gap)
  local funcName = "EMCO:setGap(gap)"
  local gapType = type(gap)
  if not gapNumber then
    self.ae(funcName, "gap expected as number, got " .. gapType)
  else
    self.gap = gapNumber
    self:reset()
  end
end

--- Sets the height of the tabs in pixels
-- @tparam number tabHeight the height of the tabs for the object, in pixels
function EMCO:setTabHeight(tabHeight)
  local tabHeightNumber = tonumber(tabHeight)
  local funcName = "EMCO:setTabHeight(tabHeight)"
  local tabHeightType = type(tabHeight)
  if not tabHeightNumber then
    self.ae(funcName, "tabHeight as number expected, got ".. tabHeightType)
  else
    self.tabHeight = tabHeightNumber
    self:reset()
  end
end

--- Enables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To enable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:enableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:enableAutoWrap()
  self.autoWrap = true
  for _,console in ipairs(self.consoles) do
    if self.mapTab and console == self.mapTabName then
      -- skip the map
    else
      self.mc[console]:enableAutoWrap()
    end
  end
end

--- Disables autowrap for the object, and by extension all attached consoles.
-- &lt;br&gt;To disable autoWrap for a specific miniconsole only, call myEMCO.windows[tabName]:disableAutoWrap()
-- but be warned if you do this it may be overwritten by future calls to EMCO:enableAutoWrap() or :disableAutoWrap()
function EMCO:disableAutoWrap()
  self.autoWrap = false
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip Map
    else
      self.mc[console]:disableAutoWrap()
    end
  end
end

--- Sets the number of characters to wordwrap the attached consoles at.
-- &lt;br&gt;it is generally recommended to make use of autoWrap unless you need
-- a specific width for some reason
function EMCO:setWrap(wrapAt)
  local funcName = "EMCO:setWrap(wrapAt)"
  local wrapAtNumber = tonumber(wrapAt)
  local wrapAtType = type(wrapAt)
  if not wrapAtNumber then
    self.ae(funcName, "wrapAt as number expect, got " .. wrapAtType)
  else
    self.wrapAt = wrapAtNumber
    for _,console in ipairs(self.consoles) do
      if self.mapTab and self.mapTabName == console then
        -- skip the Map
      else
        self.mc[console]:setWrap(wrapAtNumber)
      end
    end
  end
end

--- Appends the current line from the MUD to a tab.
-- &lt;br&gt;depending on this object's configuration, may gag the line
-- &lt;br&gt;depending on this object's configuration, may gag the next prompt
-- @tparam string tabName The name of the tab to append the line to
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:append(tabName, excludeAll)
  local funcName = "EMCO:append(tabName, excludeAll)"
  local tabNameType = type(tabName)
  local validTab = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    self.ae(funcName, "tabName as string expected, got ".. tabNameType)
  elseif not validTab then
    self.ae(funcName, "tabName must be a tab which is contained in this object. Valid tabnames are: " .. table.concat(self.consoles, ","))
  end
  self:xEcho(tabName, nil, 'a', excludeAll)
end

function EMCO:checkEchoArgs(funcName, tabName, message, excludeAll)
  local tabNameType = type(tabName)
  local messageType = type(message)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local ae = self.ae
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif messageType ~= "string" then
    ae(funcName, "message as string expected, got " .. messageType)
  elseif not validTabName then
    ae(funcName, "tabName must be the name of a tab attached to this object. Valid names are: " .. table.concat(self.consoles, ","))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

function EMCO:xEcho(tabName, message, xtype, excludeAll)
  if self.mapTab and self.mapTabName == tabName then
    error("You cannot send text to the Map tab")
  end
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local ofr,ofg,ofb,obr,obg,obb
  if xtype == "a" then
    selectCurrentLine()
    ofr,ofg,ofb = getFgColor()
    obr,obg,obb = getBgColor()
    if self.preserveBackground then
      local r,g,b = Geyser.Color.parse(self.consoleColor)
      setBgColor(r,g,b)
    end
    copy()
    if self.preserveBackground then
      setBgColor(obr, obg, obb)
    end
    deselect()
    resetFormat()
  else
    ofr,ofg,ofb = Geyser.Color.parse("white")
    obr,obg,obb = Geyser.Color.parse(self.consoleColor)
  end
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab and tabName ~= self.allTabName then
      allTab:decho(fullTimestamp)
    end
  end
  if self.blink and tabName ~= self.currentTab then
    if not (self.allTabName == self.currentTab and not self.blinkFromAll) then
      self.tabsToBlink[tabName] = true
    end
  end
  if xtype == "a" then
    console:appendBuffer()
    if allTab then
      allTab:appendBuffer()
    end
    if self.gag then
      deleteLine()
      if self.gagPrompt then
        tempPromptTrigger(function() deleteLine() end, 1)
      end
    end
  else
    console[xtype](console, message)
    if allTab then allTab[xtype](allTab, message) end
  end
  if self.blankLine then
    console:echo("\n")
    if allTab then allTab:echo("\n") end
  end
end

--- cecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to cecho to
-- @tparam string message the message to cecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cecho(tabName, message, excludeAll)
  local funcName = "EMCO:cecho(tabName, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'cecho', excludeAll)
end

--- decho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to decho to
-- @tparam string message the message to decho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:decho(tabName, message, excludeAll)
  local funcName = "EMCO:decho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'decho', excludeAll)
end

--- hecho to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to hecho to
-- @tparam string message the message to hecho to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hecho(tabName, message, excludeAll)
  local funcName = "EMCO:hecho(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'hecho', excludeAll)
end

--- echo to a tab, maintaining functionality
-- @tparam string tabName the name of the tab to echo to
-- @tparam string message the message to echo to that tab's console
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echo(tabName, message, excludeAll)
  local funcName = "EMCO:echo(console, message, excludeAll)"
  self:checkEchoArgs(funcName, tabName, message, excludeAll)
  self:xEcho(tabName, message, 'echo', excludeAll)
end

-- internal function used for type checking echoLink/Popup arguments
function EMCO:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, popup)
  local expectedType = popup and "table" or "string"
  local textType = type(text)
  local commandsType = type(commands)
  local hintsType = type(hints)
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  local excludeAllType = type(excludeAll)
  local sf = string.format
  local ae = self.ae
  if textType ~= "string" then
    ae(funcName, "text as string expected, got " .. textType)
  elseif commandsType ~= expectedType then
    ae(funcName, sf("commands as %s expected, got %s", expectedType, commandsType))
  elseif hintsType ~= expectedType then
    ae(funcName, sf("hints as %s expected, got %s", expectedType, hintsType))
  elseif tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, sf("tabName must be a tab which exists, tab %s could not be found", tabName))
  elseif self.mapTab and tabName == self.mapTabName then
    ae(funcName, sf("You cannot echo to the map tab, and %s is configured as the mapTabName", tabName))
  elseif excludeAllType ~= "nil" and excludeAllType ~= "boolean" then
    ae(funcName, "Optional argument excludeAll expected as boolean, got " .. excludeAllType)
  end
end

-- internal function used for handling echoLink/popup
function EMCO:xLink(tabName, linkType, text, commands, hints, useCurrentFormat, excludeAll)
  local console = self.mc[tabName]
  local allTab = (self.allTab and not excludeAll and not table.contains(self.allTabExclusions, tabName) and tabName ~= self.allTabName) and self.mc[self.allTabName] or false
  local arguments = {text, commands, hints, useCurrentFormat}
  if self.timestamp then
    local colorString = ""
    if self.customTimestampColor then
      local tfr,tfg,tfb = Geyser.Color.parse(self.timestampFGColor)
      local tbr,tbg,tbb = Geyser.Color.parse(self.timestampBGColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", tfr,tfg,tfb,tbr,tbg,tbb)
    else
      local ofr,ofg,ofb = Geyser.Color.parse("white")
      local obr,obg,obb = Geyser.Color.parse(self.consoleColor)
      colorString = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;", ofr,ofg,ofb,obr,obg,obb)
    end
    local timestamp = getTime(true, self.timestampFormat)
    local fullTimestamp = string.format("%s%s&lt;r&gt; ", colorString, timestamp)
    console:decho(fullTimestamp)
    if allTab then
      allTab:decho(fullTimestamp)
    end
  end
  console[linkType](console, unpack(arguments))
  if allTab then allTab[linkType](allTab, unpack(arguments)) end
end

--- cechoLink to a tab
-- @tparam string tabName the name of the tab to cechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:cechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "cechoLink", text, command, hint, true, excludeAll)
end

--- dechoLink to a tab
-- @tparam string tabName the name of the tab to dechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:dechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "dechoLink", text, command, hint, true, excludeAll)
end

--- hechoLink to a tab
-- @tparam string tabName the name of the tab to hechoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoLink(tabName, text, command, hint, excludeAll)
  local funcName = "EMCO:hechoLink(tabName, text, command, hint)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "hechoLink", text, command, hint, true, excludeAll)
end

--- echoLink to a tab
-- @tparam string tabName the name of the tab to echoLink to
-- @tparam string text the text underlying the link
-- @tparam string command the lua code to run in string format
-- @tparam string hint the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoLink(tabName, text, command, hint, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoLink(tabName, text, command, hint, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, command, hint, excludeAll)
  self:xLink(tabName, "echoLink", text, command, hint, useCurrentFormat, excludeAll)
end

--- cechoPopup to a tab
-- @tparam string tabName the name of the tab to cechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:cechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:cechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "cechoPopup", text, commands, hints, true, excludeAll)
end

--- dechoPopup to a tab
-- @tparam string tabName the name of the tab to dechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:dechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:dechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "dechoPopup", text, commands, hints, true, excludeAll)
end

--- hechoPopup to a tab
-- @tparam string tabName the name of the tab to hechoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:hechoPopup(tabName, text, commands, hints, excludeAll)
  local funcName = "EMCO:hechoPopup(tabName, text, commands, hints)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "hechoPopup", text, commands, hints, true, excludeAll)
end

--- echoPopup to a tab
-- @tparam string tabName the name of the tab to echoPopup to
-- @tparam string text the text underlying the link
-- @tparam table commands the lua code to run in string format
-- @tparam table hints the tooltip hint to use for the link
-- @tparam boolean useCurrentFormat use the format for the window or blue on black (hyperlink colors)
-- @tparam boolean excludeAll if true, will exclude this from being mirrored to the allTab
function EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat, excludeAll)
  local funcName = "EMCO:echoPopup(tabName, text, commands, hints, useCurrentFormat)"
  self:checkLinkArgs(funcName, tabName, text, commands, hints, excludeAll, true)
  self:xLink(tabName, "echoPopup", text, commands, hints, useCurrentFormat, excludeAll)
end

--- adds a tab to the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to add to the exclusion list
function EMCO:addAllTabExclusion(tabName)
  local funcName = "EMCO:addAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  if not table.contains(self.allTabExclusions, tabName) then table.insert(self.allTabExclusions, tabName) end
end

--- removess a tab from the exclusion list for echoing to the allTab
-- @tparam string tabName the name of the tab to remove from the exclusion list
function EMCO:removeAllTabExclusion(tabName)
  local funcName = "EMCO:removeAllTabExclusion(tabName)"
  local ae = self.ae
  local tabNameType = type(tabName)
  local validTabName = table.contains(self.consoles, tabName)
  if tabNameType ~= "string" then
    ae(funcName, "tabName as string expected, got " .. tabNameType)
  elseif not validTabName then
    ae(funcName, string.format("tabName %s does not exist in this EMCO. valid tabs: " .. table.concat(self.consoles, ",")))
  end
  local index = table.index_of(self.allTabExclusions, tabName)
  if index then table.remove(self.allTabExclusions, index) end
end

--- Enable placing a blank line between all messages.
function EMCO:enableBlankLine()
  self.blankLine = true
end

--- Enable placing a blank line between all messages.
function EMCO:disableBlankLine()
  self.blankLine = false
end

--- Enable scrollbars for the miniconsoles
function EMCO:enableScrollbars()
  self.scrollbars = true
  self:adjustScrollbars()
end

--- Disable scrollbars for the miniconsoles
function EMCO:disableScrollbars()
  self.scrollbars = false
  self:adjustScrollbars()
end

function EMCO:adjustScrollbars()
  for _,console in ipairs(self.consoles) do
    if self.mapTab and self.mapTabName == console then
      -- skip the Map tab
    else
      if self.scrollbars then
        self.mc[console]:enableScrollBar()
      else
        self.mc[console]:disableScrollBar()
      end
    end
  end
end

EMCOHelper = EMCOHelper or {}
EMCOHelper.items = EMCOHelper.items or {}
function EMCOHelper:switchTab(designator)
  local args = string.split(designator, "+")
  local emcoName = args[1]
  local tabName = args[2]
  for _,emco in ipairs(EMCOHelper.items) do
    if emco.name == emcoName then
      emco:switchTab(tabName)
      return
    end
  end
end

EMCO.parent = Geyser.Container

--- Creates a new Embeddable Multi Console Object.
-- &lt;br&gt;see https://github.com/demonnic/EMCO/wiki for information on valid constraints and defaults
-- @tparam table cons table of constraints which configures the EMCO.
-- @tparam GeyserObject container The container to use as the parent for the EMCO
-- @return the newly created EMCO
function EMCO:new(cons, container)
  local funcName = "EMCO:new(cons, container)"
  cons = cons or {}
  cons.type = cons.type or "tabbedConsole"
  cons.consoles = cons.consoles or { "All" }
  if cons.mapTab then
    if not type(cons.mapTabName) == "string" then
      self:ce(funcName, [["mapTab" is true, thus constraint "mapTabName" and string expected, got ]] .. type(cons.mapTabName))
    elseif not table.contains(cons.consoles, cons.mapTabName) then
      self:ce(funcName, [["mapTabName" must be one of the consoles contained within constraint "consoles". Valid option for tha mapTab are: ]] .. table.concat(cons.consoles, ","))
    end
  end
  cons.allTabExclusions = cons.allTabExclusions or {}
  if not type(cons.allTabExclusions) == "table" then self:se(funcName, "allTabExclusions must be a table if it is provided") end
  local me = self.parent:new(cons, container)
  setmetatable(me, self)
  self.__index = self
  -- set some defaults. Almost all the defaults we had for YATCO, plus a few new ones
  if me:fuzzyBoolean(cons.timestamp) then
    me:enableTimestamp()
  else
    me:disableTimestamp()
  end
  if me:fuzzyBoolean(cons.customTimestampColor) then
    me:enableCustomTimestampColor()
  else
    me:disableCustomTimestampColor()
  end
  if me:fuzzyBoolean(cons.mapTab) then
    me.mapTab = true
  else
    me.mapTab = false
  end
  if me:fuzzyBoolean(cons.blinkFromAll) then
    me:enableBlinkFromAll()
  else
    me:disableBlinkFromAll()
  end
  if me:fuzzyBoolean(cons.preserveBackground) then
    me:enablePreserveBackground()
  else
    me:disablePreserveBackground()
  end
  if me:fuzzyBoolean(cons.gag)then
    me:enableGag()
  else
    me:disableGag()
  end
  me:setTimestampFormat(cons.timestampFormat or "HH:mm:ss")
  me:setTimestampBGColor(cons.timestampBGColor or "blue")
  me:setTimestampFGColor(cons.timestampFGColor or "red")
  if me:fuzzyBoolean(cons.allTab) then
    me:enableAllTab(cons.allTab)
  else
    me:disableAllTab()
  end
  if me:fuzzyBoolean(cons.blink) then
    me:enableBlink()
  else
    me:disableBlink()
  end
  if me:fuzzyBoolean(cons.blankLine) then
    me:enableBlankLine()
  else
    me:disableBlankLine()
  end
  if me:fuzzyBoolean(cons.scrollbars) then
    me.scrollbars = true
  else
    me.scrollbars = false
  end
  me.blinkTime = cons.blinkTime or 3
  me.fontSize = cons.fontSize or 9
  me.activeTabCSS = cons.activeTabCSS or ""
  me.inactiveTabCSS = cons.inactiveTabCSS or ""
  me.activeTabFGColor = cons.activeTabFGColor or "purple"
  me.inactiveTabFGColor = cons.inactiveTabFGColor or "white"
  me.activeTabBGColor = cons.activeTabBGColor or "&lt;0,180,0&gt;"
  me.inactiveTabBGColor = cons.inactiveTabBGColor or "&lt;60,60,60&gt;"
  me.consoleColor = cons.consoleColor or "black"
  me.tabBoxCSS = cons.tabBoxCSS or ""
  me.tabBoxColor = cons.tabBoxColor or "black"
  me.consoleContainerCSS = cons.consoleContainerCSS or ""
  me.consoleContainerColor = cons.consoleContainerColor or "black"
  me.gap = cons.gap or 1
  me.consoles = cons.consoles
  me.tabHeight = cons.tabHeight or 25
  if cons.autoWrap == nil then
    me.autoWrap = true
  else
    me.autoWrap = cons.autoWrap
  end
  me.font = cons.font
  me.tabFont = cons.tabFont
  me.wrapAt = cons.wrapAt or 300
  me.currentTab = ""
  me.tabs = {}
  me.tabsToBlink = {}
  me.mc = {}
  self.blinkTimerID = tempTimer(me.blinkTime, function() me:doBlink() end, true)
  me:reset()
  if me.allTab then me:setAllTabName(me.allTabName or me.consoles[1]) end
  table.insert(EMCOHelper.items, me)
  return me
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Mapper</name>
				<packageName>Mapper</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>EleMapper</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
--
-- v1.55
--
-- eleMap.currentRoom = Mudlet room ID
--


function count_rooms()
	local count = 0
	for dir, id in pairs(getRooms()) do
		count = count +1
	end
	cecho("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; Total Rooms: "..count.."\n")
end

function get_Colours()
	for c, id in pairs(getCustomEnvColorTable()) do
		setFgColor(id[1],id[2],id[3])
		print("setRoomEnv(ID,"..c..")")
	end
end


function add_room_neighbours(realID,exits)
if brax.map.mode == "read" then return end
if brax.map.mode == "simple" then
  for dir, exitHash in pairs(exits) do
    if not getRoomExits(realID)[dir] then
      setExitStub(realID,dir,true)
    end
  end
 return 
end
	local x,y,z = getRoomCoordinates(realID)
  for dir, exitHash in pairs(exits) do
		if not roomExists(getRoomIDbyHash(exitHash)) then
			local newx,newy,newz = calculate_Coordinates(x,y,z,dir)
			local newID = createRoomID()
      addRoom(newID)
      setRoomWeight(newID,10)
  		setRoomCoordinates(newID,newx,newy,newz)
  		setRoomArea(newID,getRoomArea(realID))
			setRoomIDbyHash(newID,exitHash)
		end
		if not getRoomExits(realID)[dir] then
  		if is_standard_exit(dir) then
  			setExit(realID,getRoomIDbyHash(exitHash),dir)
  			setExit(getRoomIDbyHash(exitHash),realID,reversemap[dir])
  		else
  			addSpecialExit(realID,getRoomIDbyHash(exitHash),dir)
  		end
    end
	end
	updateMap()
end

function is_standard_exit(dir)
	if dir == "north" then
		return true
	elseif dir == "northeast" then
		return true
	elseif dir == "east" then
		return true
	elseif dir == "southeast" then
		return true
	elseif dir == "south" then
		return true
	elseif dir == "southwest" then
		return true
	elseif dir == "west" then
		return true
	elseif dir == "northwest" then
		return true
	elseif dir == "up" then
		return true
	elseif dir == "down" then
		return true
	elseif dir == "in" then
		return true
	elseif dir == "out" then
		return true
	else
		return false
	end
end

function calculate_Coordinates(x,y,z,dir)
	if dir == "north" then
		y = y + 2
	elseif dir == "northeast" then
		x = x + 2
		y = y + 2
	elseif dir == "east" then
		x = x + 2
	elseif dir == "southeast" then
		x = x + 2
		y = y - 2
	elseif dir == "south" then
		y = y - 2
	elseif dir == "southwest" then
		x = x - 2
		y = y - 2
	elseif dir == "west" then
		x = x - 2
	elseif dir == "northwest" then
		x = x - 2
		y = y + 2
	elseif dir == "up" then
		z = z + 2
	elseif dir == "down" then
		z = z - 2
	else
		x = x + 1
		y = y + 1
	end
	return x,y,z
end

function find_room()
  gmcp.Room = gmcp.Room or {}
  if gmcp.Room.Id == nil then gmcp.Room.Id = "drakenwood.4.580481" end
	eleMap.lastRoom = eleMap.currentRoom
  eleMap.currentRoom = getRoomIDbyHash(gmcp.Room.Id)
	if roomExists(eleMap.currentRoom) then
		centerview(eleMap.currentRoom)
	else 
--		cecho("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; No Room found for &lt;red&gt;"..gmcp.Room.Id.."&lt;reset&gt;\n")
	end
end

function add_exits()
  if mapBoxContainer then 
    local mTitle = properCase((gmcp.Room.Id):match("%w*"))
    if gmcp.Room.Terrain ~= 0  then mTitle = mTitle.." - "..properCase(gmcp.Room.Terrain) end
    mapBoxContainer:setTitle(mTitle) 
  end
  if brax.map.mode == "read" then return end
	local startMatrix = getStopWatchTime(mapMatrix)	
	local newID = createRoomID()
	if roomExists(eleMap.currentRoom) then
		add_room_neighbours(eleMap.currentRoom,gmcp.Room.Exits)
	else
		find_link(gmcp.Room.Exits)
	end
end

function find_link(exits)
  for dir, id in pairs(exits) do
		local roomID = getRoomIDbyHash(id)
		if roomExists(roomID) then
			local x,y,z = getRoomCoordinates(roomID)
			local newx,newy,newz = calculate_Coordinates(x,y,z,exitmap[reversemap[dir]])
			add_room(gmcp.Room.Id,newx,newy,newz,getRoomArea(roomID))
--      setExit(eleMap.lastRoom,eleMap.currentRoom,gmcp.Char.Moved)
--			break 
		end
	end
	if not roomExists(getRoomIDbyHash(gmcp.Room.Id)) then
			local x,y,z = getRoomCoordinates(eleMap.lastRoom)
      local moved = gmcp.Char.Moved
			local newx,newy,newz = calculate_Coordinates(x,y,z,moved)
      if moved == "north" then
        y = y -2
      elseif moved == "northeast" then
        y = y +2
        x = x +2
      elseif moved == "east" then
        x = x +2
      elseif moved == "southeast" then
        y = y -2
        x = x +2
      elseif moved == "south" then
        y = y -2
      elseif moved == "southwest" then
        x = x -2
        y = y -2
      elseif moved == "west" then
        x = x -2
      elseif moved == "northwest" then
        x = x -2
        y = y +2
      elseif moved == "up" then
        z = z + 2
      elseif moved == "down" then
        z = z - 2
      else
        x = x +1
        y = y +1
      end
			cecho("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; I didn't know where to put this room! ["..gmcp.Room.Id.."] please move it manually (New Zone?)\n")
      local newArea = (gmcp.Room.Id):match("(%w*)")
      if newArea == "aerdy" then newArea = 4
      elseif newArea == "drakenwood" then newArea = 1
      elseif newArea == "valena" then newArea = 2
      elseif newArea == "rosfarren" then newArea = 3
      elseif newArea == "dunglenderry" then newArea = 5
      else newArea = getRoomArea(eleMap.lastRoom) end
			add_room(eleMap.currentRoom,newx,newy,newz,newArea)
      if is_standard_exit(moved) then
      	setExit(getRoomIDbyHash(gmcp.Room.Id),eleMap.lastRoom,reversemap[moved])
      	setExit(eleMap.lastRoom,getRoomIDbyHash(gmcp.Room.Id),moved)
      else
--	addSpecialExit(realID,getRoomIDbyHash(exitHash),reversemap[moved])
end
	end
end

function onCharMove(moveDetails)
  local moved = gmcp.Char.Moved
  if getRoomUserData(eleMap.currentRoom,"roomCMD") then
    send(getRoomUserData(eleMap.currentRoom,"roomCMD"))
  end 
  if brax.map.mode == "read" then return end
	if roomExists(eleMap.currentRoom) == false then
  		find_link(gmcp.Room.Exits)
  else
    if (is_standard_exit(moved) and brax.map.mode ~= "read") then
    	setExit(getRoomIDbyHash(gmcp.Room.Id),eleMap.lastRoom,reversemap[moved])
    	setExit(eleMap.lastRoom,getRoomIDbyHash(gmcp.Room.Id),moved)
    end
  end
  brax.moved = gmcp.Char.Moved
  gmcp.Char.Moved = nil
end

function add_room(hashID,x,y,z,area)
	local newID = createRoomID()
  local thisHash = hashID
  if thisHash == -1 then thisHash = gmcp.Room.Id end
	if hashId ~= -1 then
  	addRoom(newID)
    setRoomWeight(newID,10)
  	setRoomCoordinates(newID,x,y,z)
  	setRoomArea(newID,area)
  	setRoomIDbyHash(newID,thisHash)
  	centerview(newID)
--  	eleMap.lastRoom = eleMap.currentRoom
  	eleMap.currentRoom = newID
  	add_room_neighbours(newID,gmcp.Room.Exits)
	end
end

function purge_map()
	for id, room in pairs(getRooms()) do
		deleteRoom(id)
		print("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; Deleting =&gt; "..id.."\n")
	end	
end

reversemap = {
  n = 6,
  north = 6,
  ne = 8,
  northeast = 8,
  nw = 7,
  northwest = 7,
  e = 5,
  east = 5,
  w = 4,
  west = 4,
  s = 1,
  south = 1,
  se = 3,
  southeast = 3,
  sw = 2,
  southwest = 2,
  u = 10,
  up = 10,
  d = 9,
  down = 9,
  ["in"] = 12,
  out = 11}
exitmap = {
  n = 1,
  north = 1,
  ne = 2,
  northeast = 2,
  nw = 3,
  northwest = 3,
  e = 4,
  east = 4,
  w = 5,
  west = 5,
  s = 6,
  south = 6,
  se = 7,
  southeast = 7,
  sw = 8,
  southwest = 8,
  u = 9,
  up = 9,
  d = 10,
  down = 10,
  ["in"] = 11,
  out = 12,
  [1] = "north",
  [2] = "northeast",
  [3] = "northwest",
  [4] = "east",
  [5] = "west",
  [6] = "south",
  [7] = "southeast",
  [8] = "southwest",
  [9] = "up",
  [10] = "down",
  [11] = "in",
  [12] = "out",
}	

function mapper_Installed(_, name)
  if next(getRooms()) == nil then
    gmcp = gmcp or {}
    gmcp.Room = gmcp.Room or {}
    gmcp.Room.Id = gmcp.Room.Id or ""
    eleMap.currentRoom = getRoomIDbyHash(gmcp.Room.Id)
    brax = brax or {}
    brax.map = brax.map or {}
    brax.map.mode = "full"
  	setAreaName(1,"Drakenwood")
  	setAreaName(2,"Valena")
  	setAreaName(3,"Rosfarren")
  	setAreaName(4,"Aerdy")
		setAreaName(5,"Dun Glenderry")
    local newArea = (gmcp.Room.Id):match("(%w*)")
  	cecho("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; NEW MAP STARTED\n")
  	cecho("&lt;cyan&gt;[  MAP  ]&lt;reset&gt; Adding first room "..gmcp.Room.Id.." Assuming your in "..newArea..", Manually move to new zone if not!\n")
    if newArea == "aerdy" then newArea = 4
    elseif newArea == "drakenwood" then newArea = 1
    elseif newArea == "valena" then newArea = 2
    elseif newArea == "rosfarren" then newArea = 3
    elseif newArea == "dunglenderry" then newArea = 5
    else newArea = 1 end
		local newID = createRoomID()
  	addRoom(newID)
    setRoomWeight(newID,10)
  	setRoomCoordinates(newID,0,0,0)
  	setRoomArea(newID,newArea)
		setRoomIDbyHash(newID,gmcp.Room.Id)
  	centerview(newID)
    add_room_neighbours(newID,gmcp.Room.Exits)
  	updateMap()
  end
end

function doSpeedWalk()
    brax.STOP = false
    if #speedWalkDir == 0 then return end
--    decho("Starting speedwalking "..#speedWalkDir.." rooms. use &lt;255,0,0&gt;ui stop&lt;reset&gt; to stop\n")
    speedwalktimer(speedWalkDir, brax.speedwalkDelay, false)
end

function onSymbol(...)
	local style = arg[2]
	local rooms = arg[3]
	if style == "Post Office" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"📪")
	  end 
	elseif style == "Store" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"🛒")
	  end
	elseif style == "Bank" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"💰")
	  end
	elseif style == "Stable" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"🐴")
	  end
	elseif style == "Book" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"📖")
	  end
	elseif style == "Bar" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"🍺")
	  end
	elseif style == "Swords" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"⚔️")
	  end
	elseif style == "Gem" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"💎")
	  end
	elseif style == "Food" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"🍖")
	  end
	elseif style == "Clothes" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"👚")
	  end
	elseif style == "Bottle" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"🏺")
	  end
	elseif style == "Skull" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"💀")
	  end
	elseif style == "Clear" then
		for i = 3,arg['n'] do
			setRoomChar(arg[i],"")
	  end
	end
end

function convert_map_to_hash()
end

function mapWindowOpen()
	mapMatrix = mapMatrix or createStopWatch()
  addMapMenu("Add Symbol")
  addMapEvent("Post Office", "onSymbol","Add Symbol")
  addMapEvent("Store", "onSymbol","Add Symbol")
  addMapEvent("Stable", "onSymbol","Add Symbol")
  addMapEvent("Bank", "onSymbol","Add Symbol")
  addMapEvent("Book", "onSymbol","Add Symbol")
  addMapEvent("Swords", "onSymbol","Add Symbol")
  addMapEvent("Bar", "onSymbol","Add Symbol")
  addMapEvent("Gem", "onSymbol","Add Symbol")
  addMapEvent("Clothes", "onSymbol","Add Symbol")
  addMapEvent("Food", "onSymbol","Add Symbol")
  addMapEvent("Bottle", "onSymbol","Add Symbol")
  addMapEvent("Skull", "onSymbol","Add Symbol")
  addMapEvent("Clear", "onSymbol","Add Symbol")
	find_room()
	if not mapAlias1 then tempAlias("^map count$",[[count_rooms()]]) end
	if not mapAlias2 then tempAlias("^map colours$",[[get_Colours()]]) end
	if not mapAlias3 then tempAlias("^map purge$",[[purge_map()]]) end
end

registerAnonymousEventHandler("mapOpenEvent", "mapWindowOpen")
registerAnonymousEventHandler("onSymbol", "onSymbol")
registerAnonymousEventHandler("gmcp.Room.Id", "find_room")
registerAnonymousEventHandler("gmcp.Room.Exits", "add_exits")
registerAnonymousEventHandler("gmcp.Char.Moved", "onCharMove")
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Blacks Target</name>
			<packageName></packageName>
			<script>brax = brax or {}


brax.targetState = {
  name = nil,
  hp = 1,
  casting = nil
}

function update_target_status()
if (gmcp.Char.Target == 0 or next(gmcp.Char.Target) == nil) then
    clear_target()
else
    if (gmcp.Char.Target.name ~= nil) then
      if (brax.targetState.name ~= gmcp.Char.Target.name) then
        brax.targetState.hp = 1
      end
      brax.targetState.name = gmcp.Char.Target.name
    else
      brax.targetState.name = brax.targetState.name
    end  
    targetBar:setValue(brax.targetState.hp,1,brax.targetState.name .. " HP%: " .. string.format("%0.2f",brax.targetState.hp*100))
    targetBar:show()
end
end

function update_target_vitals()
  brax.targetState.hp = gmcp.Char.Target.Vitals.hp or brax.targetState.hp
if (brax.targetState.hp &gt; 0) then
    targetBar:setValue(brax.targetState.hp,1,brax.targetState.name .. " HP%: " .. string.format("%0.2f",brax.targetState.hp*100))
  targetBar:show()
end
end

function update_target_cast()
  local duration = gmcp.Char.Target.Cast.cast_time
  if duration &lt;= 0 then
    brax.targetState.casting = nil
  else
    brax.targetState.casting = {
      name = gmcp.Char.Target.Cast.spell,
      castTime = duration,
      timeLeft = duration
    }
    demonnic.anitimer:new(
        "T"..brax.targetState.casting.name,
        {x = 0, y = 17, height = 15, width = "100%"}, brax.targetState.casting.castTime,
        {container = targetBoxContainer, showTime = true, timerCaption = brax.targetState.casting.name, cssFront = frontCSS}
      )
  end
end

function attackers_hunters()
  info = ""
  if next(gmcp.Char.Attackers.Attack) ~= nil then
    info = info.."&lt;b&gt;*Attackers&lt;/b&gt;&lt;br&gt;"
    for i, who in pairs(gmcp.Char.Attackers.Attack) do
      info = info .. who .. "&lt;br&gt;"
    end
  end
  if next(gmcp.Char.Attackers.Hunt) ~= nil then
    info = info.."&lt;b&gt;Hunters&lt;/b&gt;&lt;br&gt;"
    for i, who in pairs(gmcp.Char.Attackers.Hunt) do
      info = info .. who .. "&lt;br&gt;"
    end
  end
    targetBox:echo(info)
end

function clear_targetBoxContainer()
  targetBox:echo("")
  targetBar:hide()
  clear_target()
end

function clear_target()
  brax.targetState.name = nil
  brax.targetState.hp = 1
  brax.targetState.Casting = nil
  targetBar:setValue(0, 1, "")
  targetBar:hide()
end


registerAnonymousEventHandler('gmcp.Char.Target', 'update_target_status')
registerAnonymousEventHandler("gmcp.Char.Target.Vitals", "update_target_vitals")
registerAnonymousEventHandler('gmcp.Char.Target.Cast', 'update_target_cast')
registerAnonymousEventHandler("gmcp.Char.Attackers", "attackers_hunters")
registerAnonymousEventHandler('gmcp.Char.Quit', 'clear_targetBoxContainer')</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<Key isActive="yes" isFolder="no">
			<name>F1</name>
			<packageName></packageName>
			<script></script>
			<command>grary</command>
			<keyCode>16777264</keyCode>
			<keyModifier>0</keyModifier>
		</Key>
		<Key isActive="yes" isFolder="no">
			<name>F2</name>
			<packageName></packageName>
			<script></script>
			<command>blast</command>
			<keyCode>16777265</keyCode>
			<keyModifier>0</keyModifier>
		</Key>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
